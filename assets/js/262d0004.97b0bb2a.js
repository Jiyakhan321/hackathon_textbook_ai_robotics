"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[3001],{3292:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-4-vision-language-action/llm-integration/llm-cognitive-planning","title":"LLM Integration for Cognitive Planning","description":"Overview","source":"@site/docs/module-4-vision-language-action/llm-integration/llm-cognitive-planning.md","sourceDirName":"module-4-vision-language-action/llm-integration","slug":"/module-4-vision-language-action/llm-integration/llm-cognitive-planning","permalink":"/hackathon_textbook_ai_robotics/docs/module-4-vision-language-action/llm-integration/llm-cognitive-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Jiyakhan321/hackathon_textbook_ai_robotics/tree/main/docs/module-4-vision-language-action/llm-integration/llm-cognitive-planning.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"LLM Integration for Action Planning","permalink":"/hackathon_textbook_ai_robotics/docs/module-4-vision-language-action/llm-integration/"},"next":{"title":"Manipulation and Interaction Systems","permalink":"/hackathon_textbook_ai_robotics/docs/module-4-vision-language-action/action-execution/manipulation-interaction"}}');var s=t(4848),i=t(8453);const o={sidebar_position:3},r="LLM Integration for Cognitive Planning",l={},c=[{value:"Overview",id:"overview",level:2},{value:"LLM Integration Architecture",id:"llm-integration-architecture",level:2},{value:"1. ROS 2 LLM Interface",id:"1-ros-2-llm-interface",level:3},{value:"2. Task Decomposition System",id:"2-task-decomposition-system",level:3},{value:"3. Action Planning and Validation",id:"3-action-planning-and-validation",level:3},{value:"Advanced Planning and Reasoning",id:"advanced-planning-and-reasoning",level:2},{value:"1. Hierarchical Task Planning",id:"1-hierarchical-task-planning",level:3},{value:"ROS 2 Action Integration",id:"ros-2-action-integration",level:2},{value:"1. ROS 2 Action Server for LLM Plans",id:"1-ros-2-action-server-for-llm-plans",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"llm-integration-for-cognitive-planning",children:"LLM Integration for Cognitive Planning"})}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(e.p,{children:"Large Language Models (LLMs) enable humanoid robots to understand complex natural language commands and convert them into executable action plans. This section covers integrating LLMs with ROS 2 systems for cognitive planning, task decomposition, and safe action sequencing. The integration allows robots to interpret high-level commands and break them down into specific robotic actions."}),"\n",(0,s.jsx)(e.h2,{id:"llm-integration-architecture",children:"LLM Integration Architecture"}),"\n",(0,s.jsx)(e.h3,{id:"1-ros-2-llm-interface",children:"1. ROS 2 LLM Interface"}),"\n",(0,s.jsx)(e.p,{children:"Creating a robust interface between LLMs and ROS 2 systems:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# llm_interface.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Bool\nfrom action_msgs.msg import GoalStatus\nfrom builtin_interfaces.msg import Time\nimport openai\nimport json\nimport asyncio\nimport threading\nfrom queue import Queue\nfrom datetime import datetime\n\nclass LLMInterface(Node):\n    """\n    Interface between LLMs and ROS 2 systems for cognitive planning\n    """\n    def __init__(self):\n        super().__init__(\'llm_interface\')\n\n        # LLM configuration\n        self.llm_model = "gpt-3.5-turbo"  # Can be configured\n        self.max_tokens = 500\n        self.temperature = 0.3  # Lower for more deterministic responses\n\n        # Context management\n        self.conversation_history = []\n        self.max_history = 10  # Keep last 10 exchanges\n\n        # Create subscribers\n        self.command_sub = self.create_subscription(\n            String,\n            \'/validated_command\',\n            self.command_callback,\n            10\n        )\n\n        self.system_status_sub = self.create_subscription(\n            String,\n            \'/system_status\',\n            self.system_status_callback,\n            10\n        )\n\n        # Create publishers\n        self.plan_pub = self.create_publisher(String, \'/action_plan\', 10)\n        self.response_pub = self.create_publisher(String, \'/llm_response\', 10)\n        self.status_pub = self.create_publisher(String, \'/llm_status\', 10)\n\n        # Request queue for handling multiple requests\n        self.request_queue = Queue(maxsize=5)\n        self.is_processing = False\n\n        # Start processing thread\n        self.processing_thread = threading.Thread(target=self.process_requests)\n        self.processing_thread.daemon = True\n        self.processing_thread.start()\n\n        self.get_logger().info(\'LLM Interface initialized\')\n\n    def command_callback(self, msg):\n        """\n        Handle incoming validated commands\n        """\n        command = msg.data.strip()\n        self.get_logger().info(f\'Received command for LLM processing: "{command}"\')\n\n        # Add to processing queue\n        try:\n            self.request_queue.put_nowait({\n                \'type\': \'command\',\n                \'data\': command,\n                \'timestamp\': self.get_clock().now().to_msg()\n            })\n        except:\n            self.get_logger().warn(\'Request queue full, dropping command\')\n\n    def system_status_callback(self, msg):\n        """\n        Handle system status updates for context\n        """\n        status = msg.data\n        # Add to conversation history for context\n        self.conversation_history.append({\n            \'role\': \'system\',\n            \'content\': f\'System status: {status}\',\n            \'timestamp\': self.get_clock().now().to_msg()\n        })\n\n    def process_requests(self):\n        """\n        Process LLM requests in background thread\n        """\n        while rclpy.ok():\n            try:\n                request = self.request_queue.get(timeout=1.0)\n\n                if request[\'type\'] == \'command\':\n                    self.process_command(request[\'data\'])\n\n                self.request_queue.task_done()\n\n            except:\n                continue\n\n    def process_command(self, command):\n        """\n        Process a command through LLM\n        """\n        if self.is_processing:\n            self.get_logger().warn(\'LLM is busy, skipping command\')\n            return\n\n        self.is_processing = True\n        self.update_status("PROCESSING")\n\n        try:\n            # Prepare context for LLM\n            context = self.build_context(command)\n\n            # Call LLM\n            response = self.call_llm(context)\n\n            # Process and publish response\n            if response:\n                self.publish_response(response)\n                self.process_llm_response(response)\n\n        except Exception as e:\n            self.get_logger().error(f\'Error processing command with LLM: {e}\')\n            error_response = {\n                \'error\': str(e),\n                \'command\': command\n            }\n            error_msg = String()\n            error_msg.data = json.dumps(error_response)\n            self.response_pub.publish(error_msg)\n\n        finally:\n            self.is_processing = False\n            self.update_status("IDLE")\n\n    def build_context(self, command):\n        """\n        Build context for LLM including robot capabilities and environment\n        """\n        # Get recent conversation history\n        recent_history = self.conversation_history[-3:] if len(self.conversation_history) > 3 else self.conversation_history\n\n        # Build context messages\n        messages = [\n            {\n                "role": "system",\n                "content": (\n                    "You are a cognitive planning assistant for a humanoid robot. "\n                    "Your role is to interpret natural language commands and break them down "\n                    "into specific, executable actions. The robot has capabilities including "\n                    "navigation, object manipulation, and basic interaction. "\n                    "Respond in JSON format with a plan that can be executed by the robot. "\n                    "Include safety checks and validation for each action."\n                )\n            }\n        ]\n\n        # Add recent history\n        for history_item in recent_history:\n            messages.append({\n                "role": history_item[\'role\'],\n                "content": history_item[\'content\']\n            })\n\n        # Add current command\n        messages.append({\n            "role": "user",\n            "content": f"Command: {command}"\n        })\n\n        return messages\n\n    def call_llm(self, messages):\n        """\n        Call the LLM with prepared context\n        """\n        try:\n            response = openai.ChatCompletion.create(\n                model=self.llm_model,\n                messages=messages,\n                max_tokens=self.max_tokens,\n                temperature=self.temperature,\n                response_format={"type": "json_object"}  # Request JSON response\n            )\n\n            content = response.choices[0].message.content\n            self.get_logger().info(f\'LLM response: {content}\')\n\n            # Add to conversation history\n            self.conversation_history.append({\n                "role": "assistant",\n                "content": content,\n                "timestamp": self.get_clock().now().to_msg()\n            })\n\n            # Keep history within limits\n            if len(self.conversation_history) > self.max_history:\n                self.conversation_history = self.conversation_history[-self.max_history:]\n\n            return content\n\n        except Exception as e:\n            self.get_logger().error(f\'Error calling LLM: {e}\')\n            return None\n\n    def process_llm_response(self, response):\n        """\n        Process LLM response and convert to action plan\n        """\n        try:\n            # Parse JSON response\n            response_data = json.loads(response)\n\n            # Convert to action plan if it\'s a plan\n            if \'actions\' in response_data or \'plan\' in response_data:\n                plan_data = response_data.get(\'plan\', response_data.get(\'actions\', []))\n                plan_json = json.dumps(plan_data)\n\n                # Publish action plan\n                plan_msg = String()\n                plan_msg.data = plan_json\n                self.plan_pub.publish(plan_msg)\n\n                self.get_logger().info(f\'Published action plan with {len(plan_data)} actions\')\n\n        except json.JSONDecodeError:\n            self.get_logger().error(\'LLM response is not valid JSON\')\n        except Exception as e:\n            self.get_logger().error(f\'Error processing LLM response: {e}\')\n\n    def publish_response(self, response):\n        """\n        Publish LLM response\n        """\n        response_msg = String()\n        response_msg.data = response\n        self.response_pub.publish(response_msg)\n\n    def update_status(self, status):\n        """\n        Update and publish status\n        """\n        status_msg = String()\n        status_msg.data = status\n        self.status_pub.publish(status_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    llm_interface = LLMInterface()\n\n    try:\n        rclpy.spin(llm_interface)\n    except KeyboardInterrupt:\n        llm_interface.get_logger().info(\'Shutting down LLM interface\')\n    finally:\n        llm_interface.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-task-decomposition-system",children:"2. Task Decomposition System"}),"\n",(0,s.jsx)(e.p,{children:"Implementing a system for decomposing complex tasks into executable actions:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# task_decomposer.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom action_msgs.msg import GoalStatus\nfrom builtin_interfaces.msg import Time\nimport json\nimport re\nfrom enum import Enum\nfrom typing import List, Dict, Any\n\nclass TaskType(Enum):\n    NAVIGATION = \"navigation\"\n    MANIPULATION = \"manipulation\"\n    PERCEPTION = \"perception\"\n    COMMUNICATION = \"communication\"\n    SAFETY = \"safety\"\n\nclass TaskDecomposer(Node):\n    \"\"\"\n    Decompose complex tasks into executable action sequences\n    \"\"\"\n    def __init__(self):\n        super().__init__('task_decomposer')\n\n        # Create subscribers\n        self.plan_sub = self.create_subscription(\n            String,\n            '/action_plan',\n            self.plan_callback,\n            10\n        )\n\n        # Create publishers\n        self.decomposed_plan_pub = self.create_publisher(String, '/decomposed_plan', 10)\n        self.action_sequence_pub = self.create_publisher(String, '/action_sequence', 10)\n\n        # Task decomposition rules\n        self.decomposition_rules = {\n            'navigation': self.decompose_navigation,\n            'manipulation': self.decompose_manipulation,\n            'perception': self.decompose_perception,\n            'complex': self.decompose_complex_task\n        }\n\n        # Known locations and objects\n        self.known_locations = {\n            'kitchen': {'x': 2.0, 'y': 3.0, 'z': 0.0},\n            'living_room': {'x': -1.0, 'y': 1.0, 'z': 0.0},\n            'bedroom': {'x': 4.0, 'y': -2.0, 'z': 0.0},\n            'office': {'x': -3.0, 'y': -1.0, 'z': 0.0}\n        }\n\n        self.known_objects = {\n            'water': 'drink',\n            'coffee': 'drink',\n            'book': 'read',\n            'cup': 'container',\n            'bottle': 'container',\n            'apple': 'food'\n        }\n\n        self.get_logger().info('Task Decomposer initialized')\n\n    def plan_callback(self, msg):\n        \"\"\"\n        Process incoming action plan and decompose it\n        \"\"\"\n        try:\n            plan_data = json.loads(msg.data)\n\n            # Decompose the plan\n            decomposed_plan = self.decompose_plan(plan_data)\n\n            # Publish decomposed plan\n            decomposed_msg = String()\n            decomposed_msg.data = json.dumps(decomposed_plan)\n            self.decomposed_plan_pub.publish(decomposed_msg)\n\n            # Create and publish action sequence\n            action_sequence = self.create_action_sequence(decomposed_plan)\n            sequence_msg = String()\n            sequence_msg.data = json.dumps(action_sequence)\n            self.action_sequence_pub.publish(sequence_msg)\n\n            self.get_logger().info(f'Decomposed plan with {len(action_sequence)} actions')\n\n        except Exception as e:\n            self.get_logger().error(f'Error decomposing plan: {e}')\n\n    def decompose_plan(self, plan_data):\n        \"\"\"\n        Decompose a plan into primitive actions\n        \"\"\"\n        if isinstance(plan_data, list):\n            # Handle list of tasks\n            decomposed_tasks = []\n            for task in plan_data:\n                decomposed_tasks.extend(self.decompose_task(task))\n            return decomposed_tasks\n        else:\n            # Handle single task\n            return self.decompose_task(plan_data)\n\n    def decompose_task(self, task):\n        \"\"\"\n        Decompose a single task into primitive actions\n        \"\"\"\n        task_type = self.identify_task_type(task)\n\n        if task_type in self.decomposition_rules:\n            return self.decomposition_rules[task_type](task)\n        else:\n            # Default decomposition for unknown tasks\n            return self.decompose_unknown_task(task)\n\n    def identify_task_type(self, task):\n        \"\"\"\n        Identify the type of task from the command\n        \"\"\"\n        task_str = json.dumps(task).lower() if isinstance(task, dict) else str(task).lower()\n\n        # Navigation tasks\n        if any(keyword in task_str for keyword in ['go to', 'move to', 'navigate', 'walk to', 'go', 'move', 'walk']):\n            return 'navigation'\n\n        # Manipulation tasks\n        if any(keyword in task_str for keyword in ['pick', 'grasp', 'grab', 'take', 'lift', 'place', 'put', 'release', 'drop']):\n            return 'manipulation'\n\n        # Perception tasks\n        if any(keyword in task_str for keyword in ['find', 'look', 'see', 'locate', 'search', 'identify', 'recognize']):\n            return 'perception'\n\n        # Complex multi-step tasks\n        if any(keyword in task_str for keyword in ['and', 'then', 'after', 'before', 'while']):\n            return 'complex'\n\n        # Default to unknown\n        return 'complex'\n\n    def decompose_navigation(self, task):\n        \"\"\"\n        Decompose navigation tasks\n        \"\"\"\n        if isinstance(task, dict):\n            target_location = task.get('location', task.get('target', ''))\n        else:\n            target_location = str(task)\n\n        # Extract target location\n        location = self.extract_location(target_location)\n\n        if location:\n            return [\n                {\n                    'action': 'move_base',\n                    'type': 'navigation',\n                    'target_location': location,\n                    'description': f'Navigate to {location}'\n                }\n            ]\n        else:\n            return [\n                {\n                    'action': 'ask_for_location',\n                    'type': 'communication',\n                    'description': 'Request clarification of destination'\n                }\n            ]\n\n    def decompose_manipulation(self, task):\n        \"\"\"\n        Decompose manipulation tasks\n        \"\"\"\n        if isinstance(task, dict):\n            obj = task.get('object', task.get('item', ''))\n            action = task.get('action', '')\n        else:\n            task_str = str(task)\n            obj = self.extract_object(task_str)\n            action = self.extract_action(task_str)\n\n        actions = []\n\n        if obj:\n            # Navigate to object if needed\n            actions.append({\n                'action': 'find_object',\n                'type': 'perception',\n                'object': obj,\n                'description': f'Locate {obj}'\n            })\n\n            # Move to object\n            actions.append({\n                'action': 'approach_object',\n                'type': 'navigation',\n                'object': obj,\n                'description': f'Move to {obj}'\n            })\n\n            # Grasp object\n            if 'pick' in action.lower() or 'grasp' in action.lower() or 'take' in action.lower():\n                actions.append({\n                    'action': 'grasp_object',\n                    'type': 'manipulation',\n                    'object': obj,\n                    'description': f'Grasp {obj}'\n                })\n            elif 'place' in action.lower() or 'put' in action.lower():\n                actions.append({\n                    'action': 'release_object',\n                    'type': 'manipulation',\n                    'object': obj,\n                    'description': f'Release {obj}'\n                })\n\n        return actions\n\n    def decompose_perception(self, task):\n        \"\"\"\n        Decompose perception tasks\n        \"\"\"\n        if isinstance(task, dict):\n            obj = task.get('object', task.get('item', ''))\n        else:\n            obj = self.extract_object(str(task))\n\n        return [\n            {\n                'action': 'search_for_object',\n                'type': 'perception',\n                'object': obj,\n                'description': f'Search for {obj}'\n            },\n            {\n                'action': 'object_recognition',\n                'type': 'perception',\n                'object': obj,\n                'description': f'Recognize {obj}'\n            }\n        ]\n\n    def decompose_complex_task(self, task):\n        \"\"\"\n        Decompose complex multi-step tasks\n        \"\"\"\n        if isinstance(task, dict):\n            return self.decompose_complex_dict_task(task)\n        else:\n            return self.decompose_complex_string_task(str(task))\n\n    def decompose_complex_dict_task(self, task):\n        \"\"\"\n        Decompose complex task from dictionary\n        \"\"\"\n        actions = []\n\n        # Look for subtasks\n        if 'subtasks' in task:\n            for subtask in task['subtasks']:\n                actions.extend(self.decompose_task(subtask))\n        elif 'steps' in task:\n            for step in task['steps']:\n                actions.extend(self.decompose_task(step))\n\n        return actions\n\n    def decompose_complex_string_task(self, task_str):\n        \"\"\"\n        Decompose complex task from string\n        \"\"\"\n        actions = []\n\n        # Split on common conjunctions\n        subtasks = re.split(r'\\band\\b|\\bthen\\b|\\bafter\\b|\\bbefore\\b', task_str, flags=re.IGNORECASE)\n\n        for subtask in subtasks:\n            subtask = subtask.strip()\n            if subtask:\n                actions.extend(self.decompose_task(subtask))\n\n        return actions\n\n    def decompose_unknown_task(self, task):\n        \"\"\"\n        Decompose unknown task type\n        \"\"\"\n        return [\n            {\n                'action': 'request_clarification',\n                'type': 'communication',\n                'task': str(task),\n                'description': f'Cannot understand task: {task}'\n            }\n        ]\n\n    def extract_location(self, text):\n        \"\"\"\n        Extract known location from text\n        \"\"\"\n        text_lower = text.lower()\n        for location in self.known_locations:\n            if location in text_lower:\n                return location\n        return None\n\n    def extract_object(self, text):\n        \"\"\"\n        Extract known object from text\n        \"\"\"\n        text_lower = text.lower()\n        for obj in self.known_objects:\n            if obj in text_lower:\n                return obj\n        return None\n\n    def extract_action(self, text):\n        \"\"\"\n        Extract action verb from text\n        \"\"\"\n        # Common action verbs for manipulation\n        action_verbs = [\n            'pick', 'grasp', 'grab', 'take', 'lift', 'place', 'put', 'release', 'drop',\n            'move', 'go', 'walk', 'navigate', 'find', 'look', 'see', 'locate'\n        ]\n\n        text_lower = text.lower()\n        for verb in action_verbs:\n            if verb in text_lower:\n                return verb\n\n        return 'unknown'\n\n    def create_action_sequence(self, decomposed_plan):\n        \"\"\"\n        Create a sequence of actions from decomposed plan\n        \"\"\"\n        sequence = []\n\n        for action in decomposed_plan:\n            sequence.append({\n                'id': len(sequence) + 1,\n                'action': action.get('action', ''),\n                'type': action.get('type', ''),\n                'parameters': action,\n                'description': action.get('description', ''),\n                'dependencies': [],  # Add dependencies if needed\n                'timeout': 30.0,     # Default timeout\n                'retry_count': 3     # Default retry count\n            })\n\n        return sequence\n\ndef main(args=None):\n    rclpy.init(args=args)\n    decomposer = TaskDecomposer()\n\n    try:\n        rclpy.spin(decomposer)\n    except KeyboardInterrupt:\n        decomposer.get_logger().info('Shutting down task decomposer')\n    finally:\n        decomposer.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-action-planning-and-validation",children:"3. Action Planning and Validation"}),"\n",(0,s.jsx)(e.p,{children:"Implementing safe action planning with validation:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# action_planner_validator.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Bool\nfrom geometry_msgs.msg import Pose, Point\nfrom nav_msgs.msg import OccupancyGrid\nfrom sensor_msgs.msg import LaserScan\nimport json\nimport numpy as np\nfrom typing import Dict, Any\n\nclass ActionPlannerValidator(Node):\n    \"\"\"\n    Plan actions with safety validation and environment awareness\n    \"\"\"\n    def __init__(self):\n        super().__init__('action_planner_validator')\n\n        # Create subscribers\n        self.action_sequence_sub = self.create_subscription(\n            String,\n            '/action_sequence',\n            self.action_sequence_callback,\n            10\n        )\n\n        self.map_sub = self.create_subscription(\n            OccupancyGrid,\n            '/map',\n            self.map_callback,\n            10\n        )\n\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.scan_callback,\n            10\n        )\n\n        # Create publishers\n        self.validated_plan_pub = self.create_publisher(String, '/validated_action_plan', 10)\n        self.safety_check_pub = self.create_publisher(Bool, '/safety_check_result', 10)\n\n        # Environment data\n        self.map_data = None\n        self.scan_data = None\n        self.map_resolution = 0.05\n        self.robot_radius = 0.4  # 40cm safety margin\n\n        # Safety parameters\n        self.min_distance_to_obstacle = 0.5  # 50cm minimum\n        self.max_navigation_distance = 20.0  # 20m maximum\n\n        self.get_logger().info('Action Planner Validator initialized')\n\n    def action_sequence_callback(self, msg):\n        \"\"\"\n        Process incoming action sequence and validate it\n        \"\"\"\n        try:\n            action_sequence = json.loads(msg.data)\n\n            # Validate each action in the sequence\n            validated_sequence = []\n            all_safe = True\n\n            for i, action in enumerate(action_sequence):\n                is_safe, safety_issues = self.validate_action(action)\n\n                if is_safe:\n                    validated_sequence.append(action)\n                else:\n                    self.get_logger().warn(f'Unsafe action at index {i}: {safety_issues}')\n                    all_safe = False\n\n                    # Try to find alternative for unsafe action\n                    alternative = self.find_alternative_action(action)\n                    if alternative:\n                        validated_sequence.append(alternative)\n                        all_safe = True\n\n            # Publish validated plan\n            validated_msg = String()\n            validated_msg.data = json.dumps(validated_sequence)\n            self.validated_plan_pub.publish(validated_msg)\n\n            # Publish safety status\n            safety_msg = Bool()\n            safety_msg.data = all_safe\n            self.safety_check_pub.publish(safety_msg)\n\n            self.get_logger().info(f'Validated action sequence: {len(validated_sequence)} safe actions')\n\n        except Exception as e:\n            self.get_logger().error(f'Error validating action sequence: {e}')\n\n    def validate_action(self, action):\n        \"\"\"\n        Validate a single action for safety\n        \"\"\"\n        action_type = action.get('type', '')\n        safety_issues = []\n\n        if action_type == 'navigation':\n            safety_issues.extend(self.validate_navigation_action(action))\n        elif action_type == 'manipulation':\n            safety_issues.extend(self.validate_manipulation_action(action))\n        elif action_type == 'perception':\n            safety_issues.extend(self.validate_perception_action(action))\n\n        return len(safety_issues) == 0, safety_issues\n\n    def validate_navigation_action(self, action):\n        \"\"\"\n        Validate navigation action for safety\n        \"\"\"\n        safety_issues = []\n\n        # Check target location\n        target_location = action.get('target_location', {})\n        if not target_location:\n            safety_issues.append('No target location specified')\n\n        # If we have map data, check path safety\n        if self.map_data and isinstance(target_location, dict):\n            try:\n                # Convert target to map coordinates\n                target_x = target_location.get('x', 0)\n                target_y = target_location.get('y', 0)\n\n                # Check if target is reachable\n                target_map_x = int((target_x - self.map_data.info.origin.position.x) / self.map_data.info.resolution)\n                target_map_y = int((target_y - self.map_data.info.origin.position.y) / self.map_data.info.resolution)\n\n                if (0 <= target_map_x < self.map_data.info.width and\n                    0 <= target_map_y < self.map_data.info.height):\n                    # Check if target cell is free\n                    map_index = target_map_y * self.map_data.info.width + target_map_x\n                    if self.map_data.data[map_index] > 50:  # Occupancy threshold\n                        safety_issues.append(f'Target location is occupied: {target_location}')\n                else:\n                    safety_issues.append(f'Target location out of map bounds: {target_location}')\n            except Exception as e:\n                safety_issues.append(f'Error validating navigation target: {e}')\n\n        # Check navigation distance\n        if 'distance' in action:\n            distance = action['distance']\n            if distance > self.max_navigation_distance:\n                safety_issues.append(f'Navigation distance too long: {distance}m > {self.max_navigation_distance}m')\n\n        return safety_issues\n\n    def validate_manipulation_action(self, action):\n        \"\"\"\n        Validate manipulation action for safety\n        \"\"\"\n        safety_issues = []\n\n        # Check object existence and accessibility\n        obj = action.get('object', '')\n        if not obj:\n            safety_issues.append('No object specified for manipulation')\n\n        # Check if object is within robot reach\n        # This would require checking current robot state and object position\n        # For now, assume validation is done elsewhere\n\n        return safety_issues\n\n    def validate_perception_action(self, action):\n        \"\"\"\n        Validate perception action for safety\n        \"\"\"\n        safety_issues = []\n\n        # Check if robot can safely observe the area\n        # This might involve checking scan data for obstacles in viewing direction\n\n        return safety_issues\n\n    def find_alternative_action(self, unsafe_action):\n        \"\"\"\n        Find alternative action for unsafe action\n        \"\"\"\n        action_type = unsafe_action.get('type', '')\n\n        if action_type == 'navigation':\n            # Try to find a nearby safe location\n            return self.find_alternative_navigation(unsafe_action)\n        elif action_type == 'manipulation':\n            # Suggest alternative manipulation approach\n            return self.find_alternative_manipulation(unsafe_action)\n\n        return None\n\n    def find_alternative_navigation(self, action):\n        \"\"\"\n        Find alternative navigation target\n        \"\"\"\n        # For now, return a safe version of the action\n        # In practice, this would search for nearby safe locations\n        alternative = action.copy()\n        alternative['safety_status'] = 'alternative_found'\n        return alternative\n\n    def find_alternative_manipulation(self, action):\n        \"\"\"\n        Find alternative manipulation approach\n        \"\"\"\n        alternative = action.copy()\n        alternative['safety_status'] = 'alternative_approach'\n        return alternative\n\n    def map_callback(self, msg):\n        \"\"\"\n        Store map data for navigation validation\n        \"\"\"\n        self.map_data = msg\n        self.map_resolution = msg.info.resolution\n\n    def scan_callback(self, msg):\n        \"\"\"\n        Store laser scan data for obstacle detection\n        \"\"\"\n        self.scan_data = msg\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = ActionPlannerValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        validator.get_logger().info('Shutting down action planner validator')\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"advanced-planning-and-reasoning",children:"Advanced Planning and Reasoning"}),"\n",(0,s.jsx)(e.h3,{id:"1-hierarchical-task-planning",children:"1. Hierarchical Task Planning"}),"\n",(0,s.jsx)(e.p,{children:"Implementing hierarchical task planning for complex scenarios:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# hierarchical_planner.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom action_msgs.msg import GoalStatus\nimport json\nimport networkx as nx\nfrom typing import Dict, List, Tuple\n\nclass HierarchicalPlanner(Node):\n    \"\"\"\n    Hierarchical task planning system for complex humanoid tasks\n    \"\"\"\n    def __init__(self):\n        super().__init__('hierarchical_planner')\n\n        # Create subscribers\n        self.high_level_plan_sub = self.create_subscription(\n            String,\n            '/high_level_plan',\n            self.high_level_plan_callback,\n            10\n        )\n\n        # Create publishers\n        self.hierarchical_plan_pub = self.create_publisher(String, '/hierarchical_plan', 10)\n        self.task_dependency_pub = self.create_publisher(String, '/task_dependencies', 10)\n\n        # Task hierarchy database\n        self.task_database = {\n            'assembly': {\n                'preconditions': ['parts_available', 'workspace_clear'],\n                'subtasks': ['fetch_parts', 'position_parts', 'assemble'],\n                'postconditions': ['assembly_complete']\n            },\n            'navigation': {\n                'preconditions': ['path_clear', 'destination_known'],\n                'subtasks': ['localize', 'plan_path', 'execute_path'],\n                'postconditions': ['at_destination']\n            },\n            'manipulation': {\n                'preconditions': ['object_detected', 'gripper_free'],\n                'subtasks': ['approach_object', 'grasp', 'transport', 'place'],\n                'postconditions': ['object_placed']\n            }\n        }\n\n        self.get_logger().info('Hierarchical Planner initialized')\n\n    def high_level_plan_callback(self, msg):\n        \"\"\"\n        Process high-level plan and create hierarchical structure\n        \"\"\"\n        try:\n            high_level_plan = json.loads(msg.data)\n\n            # Create hierarchical plan\n            hierarchical_plan = self.create_hierarchical_plan(high_level_plan)\n\n            # Create task dependency graph\n            dependency_graph = self.create_dependency_graph(hierarchical_plan)\n\n            # Publish hierarchical plan\n            plan_msg = String()\n            plan_msg.data = json.dumps(hierarchical_plan)\n            self.hierarchical_plan_pub.publish(plan_msg)\n\n            # Publish dependency graph\n            dep_msg = String()\n            dep_msg.data = json.dumps(dependency_graph)\n            self.task_dependency_pub.publish(dep_msg)\n\n            self.get_logger().info(f'Created hierarchical plan with {len(hierarchical_plan)} tasks')\n\n        except Exception as e:\n            self.get_logger().error(f'Error creating hierarchical plan: {e}')\n\n    def create_hierarchical_plan(self, high_level_plan):\n        \"\"\"\n        Create hierarchical structure from high-level plan\n        \"\"\"\n        hierarchical_plan = []\n\n        for task in high_level_plan:\n            if isinstance(task, dict):\n                task_name = task.get('name', task.get('action', ''))\n            else:\n                task_name = str(task)\n\n            # Decompose high-level task into subtasks\n            subtasks = self.decompose_high_level_task(task_name)\n\n            # Create hierarchical task structure\n            hierarchical_task = {\n                'id': f\"task_{len(hierarchical_plan)}\",\n                'name': task_name,\n                'type': 'high_level',\n                'subtasks': subtasks,\n                'dependencies': [],\n                'priority': 1,\n                'timeout': 60.0\n            }\n\n            hierarchical_plan.append(hierarchical_task)\n\n        return hierarchical_plan\n\n    def decompose_high_level_task(self, task_name):\n        \"\"\"\n        Decompose high-level task into subtasks\n        \"\"\"\n        if task_name.lower() in self.task_database:\n            return self.create_subtasks_from_database(task_name)\n        else:\n            return self.create_generic_subtasks(task_name)\n\n    def create_subtasks_from_database(self, task_name):\n        \"\"\"\n        Create subtasks based on predefined task database\n        \"\"\"\n        task_info = self.task_database[task_name.lower()]\n        subtasks = []\n\n        for i, subtask_name in enumerate(task_info['subtasks']):\n            subtask = {\n                'id': f\"{task_name.lower()}_subtask_{i}\",\n                'name': subtask_name,\n                'type': 'primitive',\n                'preconditions': task_info['preconditions'],\n                'postconditions': [],\n                'parameters': {},\n                'timeout': 30.0,\n                'priority': 2 + i\n            }\n            subtasks.append(subtask)\n\n        return subtasks\n\n    def create_generic_subtasks(self, task_name):\n        \"\"\"\n        Create generic subtasks for unknown task types\n        \"\"\"\n        # Generic decomposition based on task patterns\n        if 'move' in task_name.lower() or 'go' in task_name.lower():\n            return self.create_navigation_subtasks()\n        elif 'pick' in task_name.lower() or 'grasp' in task_name.lower():\n            return self.create_manipulation_subtasks()\n        else:\n            return [self.create_generic_subtask(task_name)]\n\n    def create_navigation_subtasks(self):\n        \"\"\"\n        Create navigation subtasks\n        \"\"\"\n        return [\n            {\n                'id': 'nav_localize',\n                'name': 'localize',\n                'type': 'primitive',\n                'preconditions': ['amcl_running'],\n                'postconditions': ['position_known'],\n                'parameters': {},\n                'timeout': 10.0,\n                'priority': 2\n            },\n            {\n                'id': 'nav_plan_path',\n                'name': 'plan_path',\n                'type': 'primitive',\n                'preconditions': ['map_available', 'goal_set'],\n                'postconditions': ['path_planned'],\n                'parameters': {},\n                'timeout': 10.0,\n                'priority': 3\n            },\n            {\n                'id': 'nav_execute_path',\n                'name': 'execute_path',\n                'type': 'primitive',\n                'preconditions': ['path_planned'],\n                'postconditions': ['at_goal'],\n                'parameters': {},\n                'timeout': 60.0,\n                'priority': 4\n            }\n        ]\n\n    def create_manipulation_subtasks(self):\n        \"\"\"\n        Create manipulation subtasks\n        \"\"\"\n        return [\n            {\n                'id': 'manip_approach',\n                'name': 'approach_object',\n                'type': 'primitive',\n                'preconditions': ['object_detected'],\n                'postconditions': ['at_object'],\n                'parameters': {},\n                'timeout': 15.0,\n                'priority': 2\n            },\n            {\n                'id': 'manip_grasp',\n                'name': 'grasp_object',\n                'type': 'primitive',\n                'preconditions': ['at_object', 'gripper_open'],\n                'postconditions': ['object_grasped'],\n                'parameters': {},\n                'timeout': 10.0,\n                'priority': 3\n            },\n            {\n                'id': 'manip_transport',\n                'name': 'transport_object',\n                'type': 'primitive',\n                'preconditions': ['object_grasped'],\n                'postconditions': ['at_destination'],\n                'parameters': {},\n                'timeout': 30.0,\n                'priority': 4\n            },\n            {\n                'id': 'manip_place',\n                'name': 'place_object',\n                'type': 'primitive',\n                'preconditions': ['at_destination'],\n                'postconditions': ['object_released'],\n                'parameters': {},\n                'timeout': 10.0,\n                'priority': 5\n            }\n        ]\n\n    def create_generic_subtask(self, task_name):\n        \"\"\"\n        Create a generic subtask\n        \"\"\"\n        return {\n            'id': f'generic_{task_name.lower().replace(\" \", \"_\")}',\n            'name': task_name,\n            'type': 'primitive',\n            'preconditions': [],\n            'postconditions': [],\n            'parameters': {},\n            'timeout': 30.0,\n            'priority': 2\n        }\n\n    def create_dependency_graph(self, hierarchical_plan):\n        \"\"\"\n        Create task dependency graph\n        \"\"\"\n        G = nx.DiGraph()\n\n        # Add nodes for all tasks\n        for task in hierarchical_plan:\n            G.add_node(task['id'], task=task)\n\n            # Add nodes for subtasks\n            for subtask in task.get('subtasks', []):\n                G.add_node(subtask['id'], task=subtask)\n                # Add dependency: subtask depends on parent\n                G.add_edge(task['id'], subtask['id'])\n\n        # Create dependency structure\n        dependency_graph = {\n            'nodes': [],\n            'edges': []\n        }\n\n        for node_id in G.nodes():\n            node_data = G.nodes[node_id]['task']\n            dependency_graph['nodes'].append({\n                'id': node_id,\n                'task': node_data\n            })\n\n        for edge in G.edges():\n            dependency_graph['edges'].append({\n                'source': edge[0],\n                'target': edge[1]\n            })\n\n        return dependency_graph\n\ndef main(args=None):\n    rclpy.init(args=args)\n    hierarchical_planner = HierarchicalPlanner()\n\n    try:\n        rclpy.spin(hierarchical_planner)\n    except KeyboardInterrupt:\n        hierarchical_planner.get_logger().info('Shutting down hierarchical planner')\n    finally:\n        hierarchical_planner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"ros-2-action-integration",children:"ROS 2 Action Integration"}),"\n",(0,s.jsx)(e.h3,{id:"1-ros-2-action-server-for-llm-plans",children:"1. ROS 2 Action Server for LLM Plans"}),"\n",(0,s.jsx)(e.p,{children:"Creating an action server to execute LLM-generated plans:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# llm_action_server.py\nimport rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\nimport json\nfrom threading import Lock\nimport time\n\nfrom humanoid_interfaces.action import ExecutePlan  # Custom action definition\n\nclass LLMActionServer(Node):\n    \"\"\"\n    ROS 2 Action Server for executing LLM-generated plans\n    \"\"\"\n    def __init__(self):\n        super().__init__('llm_action_server')\n\n        # Create action server\n        self._action_server = ActionServer(\n            self,\n            ExecutePlan,\n            'execute_llm_plan',\n            self.execute_callback,\n            callback_group=ReentrantCallbackGroup()\n        )\n\n        self._mutex = Lock()\n        self.current_plan = None\n        self.is_executing = False\n\n        # Action execution interface\n        self.action_interfaces = {\n            'move_base': self.execute_navigation,\n            'grasp_object': self.execute_manipulation,\n            'find_object': self.execute_perception,\n            'ask_for_location': self.execute_communication\n        }\n\n        self.get_logger().info('LLM Action Server initialized')\n\n    def execute_callback(self, goal_handle):\n        \"\"\"\n        Execute the LLM-generated plan\n        \"\"\"\n        self.get_logger().info('Received execute plan goal')\n\n        # Parse the plan from goal\n        try:\n            plan_data = json.loads(goal_handle.request.plan_json)\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid plan JSON')\n            goal_handle.abort()\n            result = ExecutePlan.Result()\n            result.success = False\n            result.message = 'Invalid plan JSON'\n            return result\n\n        # Check if we can execute the plan\n        if self.is_executing:\n            self.get_logger().warn('Action server already executing, aborting')\n            goal_handle.abort()\n            result = ExecutePlan.Result()\n            result.success = False\n            result.message = 'Server already executing'\n            return result\n\n        with self._mutex:\n            self.is_executing = True\n            self.current_plan = plan_data\n\n        # Execute each action in the plan\n        feedback = ExecutePlan.Feedback()\n        result = ExecutePlan.Result()\n\n        try:\n            for i, action in enumerate(plan_data):\n                # Check if goal was cancelled\n                if goal_handle.is_cancel_requested:\n                    goal_handle.canceled()\n                    result.success = False\n                    result.message = 'Goal cancelled'\n                    return result\n\n                # Update feedback\n                feedback.current_action = f\"Executing: {action.get('name', 'unknown')}\"\n                feedback.progress = float(i + 1) / len(plan_data) * 100.0\n                goal_handle.publish_feedback(feedback)\n\n                # Execute the action\n                action_name = action.get('action', '')\n                if action_name in self.action_interfaces:\n                    success, message = self.action_interfaces[action_name](action)\n                    if not success:\n                        self.get_logger().error(f'Action failed: {message}')\n                        goal_handle.abort()\n                        result.success = False\n                        result.message = f'Action failed: {message}'\n                        return result\n                else:\n                    self.get_logger().error(f'Unknown action: {action_name}')\n                    goal_handle.abort()\n                    result.success = False\n                    result.message = f'Unknown action: {action_name}'\n                    return result\n\n        except Exception as e:\n            self.get_logger().error(f'Error executing plan: {e}')\n            goal_handle.abort()\n            result.success = False\n            result.message = f'Execution error: {str(e)}'\n            return result\n\n        finally:\n            with self._mutex:\n                self.is_executing = False\n                self.current_plan = None\n\n        # Plan completed successfully\n        goal_handle.succeed()\n        result.success = True\n        result.message = 'Plan executed successfully'\n        return result\n\n    def execute_navigation(self, action):\n        \"\"\"\n        Execute navigation action\n        \"\"\"\n        self.get_logger().info(f'Executing navigation: {action}')\n        # In real implementation, this would call navigation stack\n        time.sleep(2.0)  # Simulate execution time\n        return True, \"Navigation completed\"\n\n    def execute_manipulation(self, action):\n        \"\"\"\n        Execute manipulation action\n        \"\"\"\n        self.get_logger().info(f'Executing manipulation: {action}')\n        # In real implementation, this would call manipulation stack\n        time.sleep(3.0)  # Simulate execution time\n        return True, \"Manipulation completed\"\n\n    def execute_perception(self, action):\n        \"\"\"\n        Execute perception action\n        \"\"\"\n        self.get_logger().info(f'Executing perception: {action}')\n        # In real implementation, this would call perception stack\n        time.sleep(1.0)  # Simulate execution time\n        return True, \"Perception completed\"\n\n    def execute_communication(self, action):\n        \"\"\"\n        Execute communication action\n        \"\"\"\n        self.get_logger().info(f'Executing communication: {action}')\n        # In real implementation, this would call text-to-speech or similar\n        time.sleep(1.0)  # Simulate execution time\n        return True, \"Communication completed\"\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    action_server = LLMActionServer()\n\n    # Use MultiThreadedExecutor to handle callbacks in separate threads\n    executor = MultiThreadedExecutor()\n    executor.add_node(action_server)\n\n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        action_server.get_logger().info('Shutting down LLM action server')\n    finally:\n        action_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(e.p,{children:"With the LLM integration and cognitive planning system properly implemented, you're ready to move on to integrating vision systems with action planning. The next section will cover connecting computer vision perception with the cognitive planning system to enable robots to recognize objects, understand scenes, and execute vision-guided actions."})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var a=t(6540);const s={},i=a.createContext(s);function o(n){const e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);