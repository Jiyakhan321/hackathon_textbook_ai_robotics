"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4600],{5503:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-digital-twin/unity-simulation/unity-ros-communication","title":"Unity-ROS Communication Implementation","description":"Overview","source":"@site/docs/module-2-digital-twin/unity-simulation/unity-ros-communication.md","sourceDirName":"module-2-digital-twin/unity-simulation","slug":"/module-2-digital-twin/unity-simulation/unity-ros-communication","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/unity-simulation/unity-ros-communication","draft":false,"unlisted":false,"editUrl":"https://github.com/Jiyakhan321/hackathon_textbook_ai_robotics/tree/main/docs/module-2-digital-twin/unity-simulation/unity-ros-communication.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Environment Creation for Humanoid Robots in Unity","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/unity-simulation/environment-creation"},"next":{"title":"Sensor Simulation in Unity","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/unity-simulation/sensor-simulation"}}');var o=i(4848),a=i(8453);const r={sidebar_position:4},s="Unity-ROS Communication Implementation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Setting Up ROS Communication in Unity",id:"setting-up-ros-communication-in-unity",level:2},{value:"1. ROS TCP Connector Configuration",id:"1-ros-tcp-connector-configuration",level:3},{value:"2. Joint State Publisher for Humanoid Robots",id:"2-joint-state-publisher-for-humanoid-robots",level:3},{value:"3. Joint State Subscriber for Control Commands",id:"3-joint-state-subscriber-for-control-commands",level:3},{value:"Sensor Data Communication",id:"sensor-data-communication",level:2},{value:"1. IMU Sensor Publisher",id:"1-imu-sensor-publisher",level:3},{value:"2. Camera Sensor Publisher",id:"2-camera-sensor-publisher",level:3},{value:"Communication Architecture Best Practices",id:"communication-architecture-best-practices",level:2},{value:"1. Network Configuration",id:"1-network-configuration",level:3},{value:"2. Message Throttling and Buffering",id:"2-message-throttling-and-buffering",level:3},{value:"Error Handling and Diagnostics",id:"error-handling-and-diagnostics",level:2},{value:"1. Connection Monitoring",id:"1-connection-monitoring",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Efficient Message Serialization",id:"1-efficient-message-serialization",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"1. Communication Validation Script",id:"1-communication-validation-script",level:3},{value:"Next Steps",id:"next-steps",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"unity-ros-communication-implementation",children:"Unity-ROS Communication Implementation"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Establishing reliable communication between Unity and ROS 2 is crucial for creating effective digital twin environments for humanoid robots. This section covers the implementation of ROS communication in Unity using the Unity Robotics Hub, focusing on real-time data exchange, sensor simulation, and control systems."}),"\n",(0,o.jsx)(e.h2,{id:"setting-up-ros-communication-in-unity",children:"Setting Up ROS Communication in Unity"}),"\n",(0,o.jsx)(e.h3,{id:"1-ros-tcp-connector-configuration",children:"1. ROS TCP Connector Configuration"}),"\n",(0,o.jsx)(e.p,{children:"The ROS TCP Connector is the primary communication bridge between Unity and ROS 2. Here's how to properly configure it:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Std;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ROSCommunicationManager : MonoBehaviour\n{\n    [Header("ROS Connection Settings")]\n    [SerializeField] private string rosIPAddress = "127.0.0.1";\n    [SerializeField] private int rosPort = 10000;\n    [SerializeField] private float connectionRetryDelay = 2.0f;\n\n    [Header("Communication Settings")]\n    [SerializeField] private float publishRate = 50.0f; // Hz\n    [SerializeField] private bool enableLogging = true;\n\n    private ROSConnection rosConnection;\n    private bool isConnected = false;\n    private float publishTimer = 0.0f;\n\n    void Start()\n    {\n        InitializeROSConnection();\n    }\n\n    private void InitializeROSConnection()\n    {\n        try\n        {\n            rosConnection = ROSConnection.instance;\n            rosConnection.RegisteredAsConnected();\n\n            // Attempt to connect to ROS\n            StartCoroutine(TryConnectToROS());\n        }\n        catch (System.Exception ex)\n        {\n            Debug.LogError($"Failed to initialize ROS connection: {ex.Message}");\n        }\n    }\n\n    private IEnumerator TryConnectToROS()\n    {\n        while (!isConnected)\n        {\n            try\n            {\n                rosConnection.ConnectToEditor(rosIPAddress, rosPort);\n                isConnected = rosConnection.IsConnected();\n\n                if (isConnected)\n                {\n                    if (enableLogging)\n                        Debug.Log($"Successfully connected to ROS at {rosIPAddress}:{rosPort}");\n                    break;\n                }\n                else\n                {\n                    if (enableLogging)\n                        Debug.LogWarning($"Connection failed, retrying in {connectionRetryDelay}s");\n                    yield return new WaitForSeconds(connectionRetryDelay);\n                }\n            }\n            catch (System.Exception ex)\n            {\n                if (enableLogging)\n                    Debug.LogError($"Connection error: {ex.Message}");\n                yield return new WaitForSeconds(connectionRetryDelay);\n            }\n        }\n    }\n\n    void Update()\n    {\n        if (isConnected)\n        {\n            publishTimer += Time.deltaTime;\n            float publishInterval = 1.0f / publishRate;\n\n            if (publishTimer >= publishInterval)\n            {\n                PublishDataToROS();\n                publishTimer = 0.0f;\n            }\n        }\n    }\n\n    private void PublishDataToROS()\n    {\n        // Override this method in derived classes to publish specific data\n    }\n\n    public bool IsConnected()\n    {\n        return isConnected && rosConnection != null && rosConnection.IsConnected();\n    }\n\n    public void SendToROS(string topicName, object message)\n    {\n        if (IsConnected())\n        {\n            rosConnection.SendUnityMessage(topicName, message);\n        }\n        else if (enableLogging)\n        {\n            Debug.LogWarning($"Cannot send to ROS: Not connected to topic {topicName}");\n        }\n    }\n\n    public void SubscribeToROS<T>(string topicName, System.Action<T> callback) where T : Message\n    {\n        if (IsConnected())\n        {\n            rosConnection.Subscribe<T>(topicName, callback);\n        }\n        else if (enableLogging)\n        {\n            Debug.LogWarning($"Cannot subscribe to ROS: Not connected to topic {topicName}");\n        }\n    }\n\n    void OnApplicationQuit()\n    {\n        if (rosConnection != null)\n        {\n            rosConnection.Disconnect();\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-joint-state-publisher-for-humanoid-robots",children:"2. Joint State Publisher for Humanoid Robots"}),"\n",(0,o.jsx)(e.p,{children:"Publishing joint states from Unity to ROS 2 is essential for synchronization:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor;\nusing System.Collections.Generic;\n\npublic class JointStatePublisher : MonoBehaviour\n{\n    [Header("Joint Configuration")]\n    [SerializeField] private ArticulationBody[] jointBodies;\n    [SerializeField] private string[] jointNames;\n    [SerializeField] private string robotName = "humanoid_robot";\n\n    [Header("Publishing Settings")]\n    [SerializeField] private string jointStatesTopic = "/joint_states";\n    [SerializeField] private float publishRate = 50.0f;\n\n    private ROSConnection rosConnection;\n    private float publishTimer = 0.0f;\n    private List<double> jointPositions;\n    private List<double> jointVelocities;\n    private List<double> jointEfforts;\n\n    void Start()\n    {\n        InitializeJointArrays();\n        rosConnection = ROSConnection.instance;\n    }\n\n    private void InitializeJointArrays()\n    {\n        if (jointBodies.Length != jointNames.Length)\n        {\n            Debug.LogError("Joint bodies and joint names arrays must have the same length!");\n            return;\n        }\n\n        jointPositions = new List<double>(new double[jointBodies.Length]);\n        jointVelocities = new List<double>(new double[jointBodies.Length]);\n        jointEfforts = new List<double>(new double[jointBodies.Length]);\n    }\n\n    void Update()\n    {\n        publishTimer += Time.deltaTime;\n        float publishInterval = 1.0f / publishRate;\n\n        if (publishTimer >= publishInterval)\n        {\n            PublishJointStates();\n            publishTimer = 0.0f;\n        }\n    }\n\n    private void PublishJointStates()\n    {\n        if (jointBodies == null || jointBodies.Length == 0 || rosConnection == null)\n            return;\n\n        // Update joint arrays with current values\n        for (int i = 0; i < jointBodies.Length; i++)\n        {\n            if (jointBodies[i] != null)\n            {\n                jointPositions[i] = jointBodies[i].jointPosition[0];\n                jointVelocities[i] = jointBodies[i].jointVelocity[0];\n                jointEfforts[i] = jointBodies[i].jointForce[0];\n            }\n        }\n\n        // Create and publish joint state message\n        JointStateMsg jointState = new JointStateMsg\n        {\n            name = jointNames,\n            position = jointPositions.ToArray(),\n            velocity = jointVelocities.ToArray(),\n            effort = jointEfforts.ToArray(),\n            header = new Unity.Robotics.ROSTCPConnector.MessageTypes.Std.HeaderMsg\n            {\n                stamp = new Unity.Robotics.ROSTCPConnector.MessageTypes.BuiltinInterfaces.TimeMsg\n                {\n                    sec = (int)Time.time,\n                    nanosec = (uint)((Time.time % 1) * 1000000000)\n                },\n                frame_id = robotName\n            }\n        };\n\n        rosConnection.SendUnityMessage(jointStatesTopic, jointState);\n    }\n\n    public void SetJointBodies(ArticulationBody[] bodies)\n    {\n        jointBodies = bodies;\n        if (jointNames == null || jointNames.Length != bodies.Length)\n        {\n            jointNames = new string[bodies.Length];\n            for (int i = 0; i < bodies.Length; i++)\n            {\n                jointNames[i] = bodies[i].name;\n            }\n        }\n        InitializeJointArrays();\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"3-joint-state-subscriber-for-control-commands",children:"3. Joint State Subscriber for Control Commands"}),"\n",(0,o.jsx)(e.p,{children:"Receiving joint commands from ROS 2 to control the Unity robot:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor;\nusing System.Collections.Generic;\n\npublic class JointStateSubscriber : MonoBehaviour\n{\n    [Header("Joint Configuration")]\n    [SerializeField] private Dictionary<string, ArticulationBody> jointMap = new Dictionary<string, ArticulationBody>();\n    [SerializeField] private string jointCommandsTopic = "/joint_commands";\n\n    [Header("Control Settings")]\n    [SerializeField] private float positionGain = 3000f;  // kp\n    [SerializeField] private float velocityGain = 200f;   // kd\n    [SerializeField] private float forceLimit = 1000f;\n\n    private ROSConnection rosConnection;\n    private Dictionary<string, double> targetPositions = new Dictionary<string, double>();\n    private Dictionary<string, double> targetVelocities = new Dictionary<string, double>();\n\n    void Start()\n    {\n        rosConnection = ROSConnection.instance;\n\n        // Subscribe to joint commands\n        rosConnection.Subscribe<JointStateMsg>(jointCommandsTopic, OnJointCommandReceived);\n\n        // Initialize joint map\n        InitializeJointMap();\n    }\n\n    private void InitializeJointMap()\n    {\n        jointMap.Clear();\n\n        // Find all ArticulationBodies in children\n        ArticulationBody[] bodies = GetComponentsInChildren<ArticulationBody>();\n        foreach (ArticulationBody body in bodies)\n        {\n            if (!jointMap.ContainsKey(body.name))\n            {\n                jointMap[body.name] = body;\n            }\n        }\n    }\n\n    private void OnJointCommandReceived(JointStateMsg jointState)\n    {\n        for (int i = 0; i < jointState.name.Length; i++)\n        {\n            string jointName = jointState.name[i];\n\n            if (jointMap.ContainsKey(jointName))\n            {\n                // Store target positions and velocities\n                if (i < jointState.position.Length)\n                    targetPositions[jointName] = jointState.position[i];\n\n                if (i < jointState.velocity.Length)\n                    targetVelocities[jointName] = jointState.velocity[i];\n            }\n        }\n    }\n\n    void FixedUpdate()\n    {\n        ApplyJointCommands();\n    }\n\n    private void ApplyJointCommands()\n    {\n        foreach (var jointPair in jointMap)\n        {\n            string jointName = jointPair.Key;\n            ArticulationBody jointBody = jointPair.Value;\n\n            if (targetPositions.ContainsKey(jointName))\n            {\n                double targetPos = targetPositions[jointName];\n\n                // Set drive parameters for position control\n                ArticulationDrive drive = jointBody.xDrive;\n                drive.position = (float)targetPos;\n                drive.positionSpring = positionGain;\n                drive.positionDamper = velocityGain;\n                drive.forceLimit = forceLimit;\n                drive.upperLimit = jointBody.xDrive.upperLimit;\n                drive.lowerLimit = jointBody.xDrive.lowerLimit;\n\n                jointBody.xDrive = drive;\n            }\n        }\n    }\n\n    public void AddJoint(string jointName, ArticulationBody jointBody)\n    {\n        if (!jointMap.ContainsKey(jointName))\n        {\n            jointMap[jointName] = jointBody;\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"sensor-data-communication",children:"Sensor Data Communication"}),"\n",(0,o.jsx)(e.h3,{id:"1-imu-sensor-publisher",children:"1. IMU Sensor Publisher"}),"\n",(0,o.jsx)(e.p,{children:"Publishing IMU data from Unity to ROS 2:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Geometry;\n\npublic class IMUSensorPublisher : MonoBehaviour\n{\n    [Header("IMU Configuration")]\n    [SerializeField] private string imuTopic = "/imu/data";\n    [SerializeField] private Transform imuTransform;\n    [SerializeField] private float publishRate = 100.0f;\n\n    [Header("Noise Settings")]\n    [SerializeField] private float linearAccelerationNoise = 0.01f;\n    [SerializeField] private float angularVelocityNoise = 0.001f;\n    [SerializeField] private float orientationNoise = 0.0001f;\n\n    private ROSConnection rosConnection;\n    private float publishTimer = 0.0f;\n    private Rigidbody attachedRigidbody;\n\n    void Start()\n    {\n        rosConnection = ROSConnection.instance;\n\n        if (imuTransform == null)\n            imuTransform = transform;\n\n        attachedRigidbody = GetComponent<Rigidbody>();\n    }\n\n    void Update()\n    {\n        publishTimer += Time.deltaTime;\n        float publishInterval = 1.0f / publishRate;\n\n        if (publishTimer >= publishInterval)\n        {\n            PublishIMUData();\n            publishTimer = 0.0f;\n        }\n    }\n\n    private void PublishIMUData()\n    {\n        if (rosConnection == null)\n            return;\n\n        // Get orientation (convert Unity to ROS coordinate system)\n        Quaternion orientation = imuTransform.rotation;\n        // Convert from Unity (left-handed) to ROS (right-handed) coordinate system\n        orientation = new Quaternion(orientation.x, orientation.y, -orientation.z, -orientation.w);\n\n        // Get angular velocity\n        Vector3 angularVelocity = Vector3.zero;\n        if (attachedRigidbody != null)\n        {\n            angularVelocity = attachedRigidbody.angularVelocity;\n        }\n        // Convert to ROS coordinate system\n        angularVelocity = new Vector3(angularVelocity.x, angularVelocity.y, -angularVelocity.z);\n\n        // Get linear acceleration (approximate from gravity and movement)\n        Vector3 linearAcceleration = Physics.gravity;\n        if (attachedRigidbody != null)\n        {\n            linearAcceleration += attachedRigidbody.velocity / Time.fixedDeltaTime;\n        }\n        // Convert to ROS coordinate system\n        linearAcceleration = new Vector3(linearAcceleration.x, linearAcceleration.y, -linearAcceleration.z);\n\n        // Add noise to simulate real sensor\n        orientation = AddOrientationNoise(orientation);\n        angularVelocity = AddAngularVelocityNoise(angularVelocity);\n        linearAcceleration = AddLinearAccelerationNoise(linearAcceleration);\n\n        ImuMsg imuMsg = new ImuMsg\n        {\n            header = new Unity.Robotics.ROSTCPConnector.MessageTypes.Std.HeaderMsg\n            {\n                stamp = new Unity.Robotics.ROSTCPConnector.MessageTypes.BuiltinInterfaces.TimeMsg\n                {\n                    sec = (int)Time.time,\n                    nanosec = (uint)((Time.time % 1) * 1000000000)\n                },\n                frame_id = imuTransform.name\n            },\n            orientation = new QuaternionMsg\n            {\n                x = orientation.x,\n                y = orientation.y,\n                z = orientation.z,\n                w = orientation.w\n            },\n            angular_velocity = new Vector3Msg\n            {\n                x = angularVelocity.x,\n                y = angularVelocity.y,\n                z = angularVelocity.z\n            },\n            linear_acceleration = new Vector3Msg\n            {\n                x = linearAcceleration.x,\n                y = linearAcceleration.y,\n                z = linearAcceleration.z\n            }\n        };\n\n        rosConnection.SendUnityMessage(imuTopic, imuMsg);\n    }\n\n    private Quaternion AddOrientationNoise(Quaternion orientation)\n    {\n        if (orientationNoise > 0)\n        {\n            orientation.x += Random.Range(-orientationNoise, orientationNoise);\n            orientation.y += Random.Range(-orientationNoise, orientationNoise);\n            orientation.z += Random.Range(-orientationNoise, orientationNoise);\n            orientation.w += Random.Range(-orientationNoise, orientationNoise);\n\n            // Normalize quaternion\n            float magnitude = Mathf.Sqrt(orientation.x * orientation.x +\n                                       orientation.y * orientation.y +\n                                       orientation.z * orientation.z +\n                                       orientation.w * orientation.w);\n            if (magnitude > 0)\n            {\n                orientation.x /= magnitude;\n                orientation.y /= magnitude;\n                orientation.z /= magnitude;\n                orientation.w /= magnitude;\n            }\n        }\n        return orientation;\n    }\n\n    private Vector3 AddAngularVelocityNoise(Vector3 angularVelocity)\n    {\n        if (angularVelocityNoise > 0)\n        {\n            angularVelocity.x += Random.Range(-angularVelocityNoise, angularVelocityNoise);\n            angularVelocity.y += Random.Range(-angularVelocityNoise, angularVelocityNoise);\n            angularVelocity.z += Random.Range(-angularVelocityNoise, angularVelocityNoise);\n        }\n        return angularVelocity;\n    }\n\n    private Vector3 AddLinearAccelerationNoise(Vector3 linearAcceleration)\n    {\n        if (linearAccelerationNoise > 0)\n        {\n            linearAcceleration.x += Random.Range(-linearAccelerationNoise, linearAccelerationNoise);\n            linearAcceleration.y += Random.Range(-linearAccelerationNoise, linearAccelerationNoise);\n            linearAcceleration.z += Random.Range(-linearAccelerationNoise, linearAccelerationNoise);\n        }\n        return linearAcceleration;\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-camera-sensor-publisher",children:"2. Camera Sensor Publisher"}),"\n",(0,o.jsx)(e.p,{children:"Publishing camera data from Unity cameras to ROS 2:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor;\nusing System.Collections;\nusing System.Threading.Tasks;\n\npublic class CameraSensorPublisher : MonoBehaviour\n{\n    [Header("Camera Configuration")]\n    [SerializeField] private Camera cameraComponent;\n    [SerializeField] private string imageTopic = "/camera/image_raw";\n    [SerializeField] private string infoTopic = "/camera/camera_info";\n\n    [Header("Image Settings")]\n    [SerializeField] private int imageWidth = 640;\n    [SerializeField] private int imageHeight = 480;\n    [SerializeField] private float publishRate = 30.0f;\n\n    private ROSConnection rosConnection;\n    private float publishTimer = 0.0f;\n    private RenderTexture renderTexture;\n    private Texture2D texture2D;\n    private byte[] imageBytes;\n\n    void Start()\n    {\n        rosConnection = ROSConnection.instance;\n\n        if (cameraComponent == null)\n            cameraComponent = GetComponent<Camera>();\n\n        InitializeCameraTexture();\n    }\n\n    private void InitializeCameraTexture()\n    {\n        renderTexture = new RenderTexture(imageWidth, imageHeight, 24);\n        texture2D = new Texture2D(imageWidth, imageHeight, TextureFormat.RGB24, false);\n\n        cameraComponent.targetTexture = renderTexture;\n    }\n\n    void Update()\n    {\n        publishTimer += Time.deltaTime;\n        float publishInterval = 1.0f / publishRate;\n\n        if (publishTimer >= publishInterval)\n        {\n            PublishCameraData();\n            publishTimer = 0.0f;\n        }\n    }\n\n    private void PublishCameraData()\n    {\n        if (rosConnection == null || cameraComponent == null)\n            return;\n\n        // Render the camera to texture\n        RenderTexture.active = renderTexture;\n        cameraComponent.Render();\n\n        // Read pixels from render texture\n        texture2D.ReadPixels(new Rect(0, 0, imageWidth, imageHeight), 0, 0);\n        texture2D.Apply();\n\n        // Convert to byte array\n        imageBytes = texture2D.EncodeToJPG();\n\n        // Create and publish image message\n        ImageMsg imageMsg = new ImageMsg\n        {\n            header = new Unity.Robotics.ROSTCPConnector.MessageTypes.Std.HeaderMsg\n            {\n                stamp = new Unity.Robotics.ROSTCPConnector.MessageTypes.BuiltinInterfaces.TimeMsg\n                {\n                    sec = (int)Time.time,\n                    nanosec = (uint)((Time.time % 1) * 1000000000)\n                },\n                frame_id = cameraComponent.name\n            },\n            height = (uint)imageHeight,\n            width = (uint)imageWidth,\n            encoding = "rgb8",\n            is_bigendian = 0,\n            step = (uint)(imageWidth * 3), // 3 bytes per pixel for RGB\n            data = imageBytes\n        };\n\n        rosConnection.SendUnityMessage(imageTopic, imageMsg);\n\n        // Publish camera info\n        PublishCameraInfo();\n    }\n\n    private void PublishCameraInfo()\n    {\n        CameraInfoMsg cameraInfo = new CameraInfoMsg\n        {\n            header = new Unity.Robotics.ROSTCPConnector.MessageTypes.Std.HeaderMsg\n            {\n                stamp = new Unity.Robotics.ROSTCPConnector.MessageTypes.BuiltinInterfaces.TimeMsg\n                {\n                    sec = (int)Time.time,\n                    nanosec = (uint)((Time.time % 1) * 1000000000)\n                },\n                frame_id = cameraComponent.name\n            },\n            height = (uint)imageHeight,\n            width = (uint)imageWidth,\n            distortion_model = "plumb_bob",\n            D = new double[] { 0, 0, 0, 0, 0 }, // No distortion\n            K = new double[] {\n                cameraComponent.focalLength * imageWidth / cameraComponent.sensorSize.x, 0, imageWidth / 2.0,\n                0, cameraComponent.focalLength * imageHeight / cameraComponent.sensorSize.y, imageHeight / 2.0,\n                0, 0, 1\n            },\n            R = new double[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 },\n            P = new double[] {\n                cameraComponent.focalLength * imageWidth / cameraComponent.sensorSize.x, 0, imageWidth / 2.0, 0,\n                0, cameraComponent.focalLength * imageHeight / cameraComponent.sensorSize.y, imageHeight / 2.0, 0,\n                0, 0, 1, 0\n            }\n        };\n\n        rosConnection.SendUnityMessage(infoTopic, cameraInfo);\n    }\n\n    void OnDestroy()\n    {\n        if (renderTexture != null)\n            RenderTexture.ReleaseTemporary(renderTexture);\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"communication-architecture-best-practices",children:"Communication Architecture Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"1-network-configuration",children:"1. Network Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Proper network setup is essential for stable Unity-ROS communication:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\n\n[CreateAssetMenu(fileName = "ROSNetworkConfig", menuName = "ROS/Network Configuration")]\npublic class ROSNetworkConfig : ScriptableObject\n{\n    [Header("Connection Settings")]\n    public string rosIPAddress = "127.0.0.1";\n    public int rosPort = 10000;\n\n    [Header("Performance Settings")]\n    public float publishRate = 50.0f;\n    public float connectionRetryDelay = 2.0f;\n    public int maxConnectionAttempts = 5;\n\n    [Header("Topic Configuration")]\n    public string jointStatesTopic = "/joint_states";\n    public string jointCommandsTopic = "/joint_commands";\n    public string imuTopic = "/imu/data";\n    public string imageTopic = "/camera/image_raw";\n    public string infoTopic = "/camera/camera_info";\n\n    [Header("Quality of Service")]\n    public bool enableCompression = true;\n    public float compressionQuality = 0.8f;\n    public bool enableThrottling = true;\n    public float maxMessageRate = 100.0f;\n\n    [Header("Security Settings")]\n    public bool enableEncryption = false;\n    public string encryptionKey = "default_key";\n\n    public void ValidateSettings()\n    {\n        rosPort = Mathf.Clamp(rosPort, 1024, 65535);\n        publishRate = Mathf.Clamp(publishRate, 1.0f, 1000.0f);\n        connectionRetryDelay = Mathf.Clamp(connectionRetryDelay, 0.1f, 10.0f);\n        maxConnectionAttempts = Mathf.Clamp(maxConnectionAttempts, 1, 10);\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-message-throttling-and-buffering",children:"2. Message Throttling and Buffering"}),"\n",(0,o.jsx)(e.p,{children:"Implement message throttling to prevent network overload:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:"using UnityEngine;\nusing System.Collections.Generic;\n\npublic class MessageThrottler : MonoBehaviour\n{\n    [System.Serializable]\n    public class TopicThrottleConfig\n    {\n        public string topicName;\n        public float maxRateHz = 50.0f;\n        public int maxBufferSize = 10;\n    }\n\n    [SerializeField] private List<TopicThrottleConfig> throttleConfigs = new List<TopicThrottleConfig>();\n    private Dictionary<string, MessageBuffer> messageBuffers = new Dictionary<string, MessageBuffer>();\n\n    [System.Serializable]\n    private class MessageBuffer\n    {\n        public Queue<object> buffer = new Queue<object>();\n        public float lastSendTime = 0f;\n        public float minInterval = 0.02f; // 50 Hz default\n        public int maxBufferSize = 10;\n    }\n\n    void Start()\n    {\n        InitializeBuffers();\n    }\n\n    private void InitializeBuffers()\n    {\n        foreach (var config in throttleConfigs)\n        {\n            MessageBuffer buffer = new MessageBuffer\n            {\n                minInterval = 1.0f / config.maxRateHz,\n                maxBufferSize = config.maxBufferSize\n            };\n            messageBuffers[config.topicName] = buffer;\n        }\n    }\n\n    public bool ShouldSendMessage(string topicName)\n    {\n        if (!messageBuffers.ContainsKey(topicName))\n            return true; // No throttling for this topic\n\n        MessageBuffer buffer = messageBuffers[topicName];\n        float currentTime = Time.time;\n\n        return (currentTime - buffer.lastSendTime) >= buffer.minInterval;\n    }\n\n    public void QueueMessage(string topicName, object message)\n    {\n        if (!messageBuffers.ContainsKey(topicName))\n        {\n            // If no buffer exists, send immediately\n            return;\n        }\n\n        MessageBuffer buffer = messageBuffers[topicName];\n\n        // Add to buffer\n        buffer.buffer.Enqueue(message);\n\n        // Trim buffer if too large\n        while (buffer.buffer.Count > buffer.maxBufferSize)\n        {\n            buffer.buffer.Dequeue();\n        }\n    }\n\n    public bool TryGetNextMessage(string topicName, out object message)\n    {\n        message = null;\n\n        if (!messageBuffers.ContainsKey(topicName))\n            return false;\n\n        MessageBuffer buffer = messageBuffers[topicName];\n\n        if (buffer.buffer.Count > 0 && ShouldSendMessage(topicName))\n        {\n            message = buffer.buffer.Dequeue();\n            buffer.lastSendTime = Time.time;\n            return true;\n        }\n\n        return false;\n    }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"error-handling-and-diagnostics",children:"Error Handling and Diagnostics"}),"\n",(0,o.jsx)(e.h3,{id:"1-connection-monitoring",children:"1. Connection Monitoring"}),"\n",(0,o.jsx)(e.p,{children:"Monitor and handle connection issues gracefully:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing System;\n\npublic class ROSConnectionMonitor : MonoBehaviour\n{\n    [Header("Connection Settings")]\n    [SerializeField] private float heartbeatInterval = 1.0f;\n    [SerializeField] private float timeoutThreshold = 5.0f;\n    [SerializeField] private bool enableReconnection = true;\n\n    [Header("Diagnostics")]\n    [SerializeField] private bool enableLogging = true;\n    [SerializeField] private float logInterval = 2.0f;\n\n    private float heartbeatTimer = 0.0f;\n    private float lastMessageTime = 0.0f;\n    private bool isConnectionHealthy = true;\n    private ROSCommunicationManager communicationManager;\n    private float logTimer = 0.0f;\n\n    void Start()\n    {\n        communicationManager = GetComponent<ROSCommunicationManager>();\n        lastMessageTime = Time.time;\n    }\n\n    void Update()\n    {\n        // Check heartbeat\n        heartbeatTimer += Time.deltaTime;\n        if (heartbeatTimer >= heartbeatInterval)\n        {\n            SendHeartbeat();\n            heartbeatTimer = 0.0f;\n        }\n\n        // Check for timeout\n        CheckConnectionTimeout();\n\n        // Log diagnostics periodically\n        if (enableLogging)\n        {\n            logTimer += Time.deltaTime;\n            if (logTimer >= logInterval)\n            {\n                LogDiagnostics();\n                logTimer = 0.0f;\n            }\n        }\n    }\n\n    private void SendHeartbeat()\n    {\n        if (communicationManager != null && communicationManager.IsConnected())\n        {\n            // Send a simple heartbeat message\n            var heartbeatMsg = new Unity.Robotics.ROSTCPConnector.MessageTypes.Std.StringMsg\n            {\n                data = $"heartbeat_{Time.time}"\n            };\n\n            communicationManager.SendToROS("/heartbeat", heartbeatMsg);\n            lastMessageTime = Time.time;\n        }\n    }\n\n    private void CheckConnectionTimeout()\n    {\n        float timeSinceLastMessage = Time.time - lastMessageTime;\n\n        if (timeSinceLastMessage > timeoutThreshold)\n        {\n            if (isConnectionHealthy)\n            {\n                if (enableLogging)\n                    Debug.LogWarning("ROS connection timeout detected!");\n\n                isConnectionHealthy = false;\n\n                if (enableReconnection)\n                {\n                    StartCoroutine(AttemptReconnection());\n                }\n            }\n        }\n        else\n        {\n            isConnectionHealthy = true;\n        }\n    }\n\n    private System.Collections.IEnumerator AttemptReconnection()\n    {\n        if (communicationManager != null)\n        {\n            if (enableLogging)\n                Debug.Log("Attempting to reconnect to ROS...");\n\n            // Wait a bit before attempting reconnection\n            yield return new WaitForSeconds(1.0f);\n\n            // This would typically involve restarting the ROS connection\n            // Implementation depends on your specific ROS setup\n        }\n    }\n\n    private void LogDiagnostics()\n    {\n        if (communicationManager != null)\n        {\n            string status = communicationManager.IsConnected() ? "CONNECTED" : "DISCONNECTED";\n            float timeSinceLastMsg = Time.time - lastMessageTime;\n\n            Debug.Log($"ROS Connection Status: {status} | Last message: {timeSinceLastMsg:F1}s ago | Healthy: {isConnectionHealthy}");\n        }\n    }\n\n    public bool IsConnectionHealthy()\n    {\n        return isConnectionHealthy;\n    }\n\n    public float GetTimeSinceLastMessage()\n    {\n        return Time.time - lastMessageTime;\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"1-efficient-message-serialization",children:"1. Efficient Message Serialization"}),"\n",(0,o.jsx)(e.p,{children:"Optimize message serialization for better performance:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using System.Collections.Generic;\nusing Unity.Robotics.ROSTCPConnector;\n\npublic class OptimizedMessagePublisher : MonoBehaviour\n{\n    [Header("Optimization Settings")]\n    [SerializeField] private bool enableMessagePooling = true;\n    [SerializeField] private int messagePoolSize = 100;\n\n    private Dictionary<string, Queue<object>> messagePool = new Dictionary<string, Queue<object>>();\n    private Dictionary<string, int> messageCount = new Dictionary<string, int>();\n\n    public T GetMessageFromPool<T>(string topicName) where T : new()\n    {\n        if (!enableMessagePooling)\n            return new T();\n\n        if (!messagePool.ContainsKey(topicName))\n        {\n            messagePool[topicName] = new Queue<object>();\n            messageCount[topicName] = 0;\n        }\n\n        Queue<object> pool = messagePool[topicName];\n\n        if (pool.Count > 0)\n        {\n            return (T)pool.Dequeue();\n        }\n        else\n        {\n            messageCount[topicName]++;\n            return new T();\n        }\n    }\n\n    public void ReturnMessageToPool(string topicName, object message)\n    {\n        if (!enableMessagePooling || message == null)\n            return;\n\n        if (!messagePool.ContainsKey(topicName))\n        {\n            messagePool[topicName] = new Queue<object>();\n        }\n\n        Queue<object> pool = messagePool[topicName];\n\n        // Limit pool size to prevent memory issues\n        if (pool.Count < messagePoolSize)\n        {\n            pool.Enqueue(message);\n        }\n    }\n\n    // Example of using pooled messages\n    public void PublishOptimizedJointState(string topicName, ArticulationBody[] joints, string[] jointNames)\n    {\n        var jointState = GetMessageFromPool<Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor.JointStateMsg>(topicName);\n\n        // Use the message...\n        jointState.name = jointNames;\n        // ... set other properties\n\n        // Publish the message\n        ROSConnection.instance.SendUnityMessage(topicName, jointState);\n\n        // Return to pool after a delay or when appropriate\n        ReturnMessageToPool(topicName, jointState);\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,o.jsx)(e.h3,{id:"1-communication-validation-script",children:"1. Communication Validation Script"}),"\n",(0,o.jsx)(e.p,{children:"Test and validate the communication system:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ROSCommunicationValidator : MonoBehaviour\n{\n    [Header("Validation Settings")]\n    [SerializeField] private float testDuration = 10.0f;\n    [SerializeField] private float testInterval = 0.1f;\n    [SerializeField] private string testTopic = "/test_communication";\n\n    [Header("Validation Results")]\n    [SerializeField] private bool isConnected = false;\n    [SerializeField] private int messagesSent = 0;\n    [SerializeField] private int messagesReceived = 0;\n    [SerializeField] private float lastRoundTripTime = 0.0f;\n\n    private ROSCommunicationManager communicationManager;\n    private float testStartTime = 0.0f;\n    private bool isTesting = false;\n\n    void Start()\n    {\n        communicationManager = GetComponent<ROSCommunicationManager>();\n    }\n\n    public void StartValidationTest()\n    {\n        if (isTesting) return;\n\n        if (communicationManager == null || !communicationManager.IsConnected())\n        {\n            Debug.LogError("Cannot start validation test: Not connected to ROS!");\n            return;\n        }\n\n        isTesting = true;\n        testStartTime = Time.time;\n        messagesSent = 0;\n        messagesReceived = 0;\n\n        // Subscribe to echo messages\n        communicationManager.SubscribeToROS<Unity.Robotics.ROSTCPConnector.MessageTypes.Std.StringMsg>(\n            "/echo_test", OnEchoReceived);\n\n        StartCoroutine(RunValidationTest());\n    }\n\n    private IEnumerator RunValidationTest()\n    {\n        float testStart = Time.time;\n\n        while ((Time.time - testStart) < testDuration && isTesting)\n        {\n            // Send test message\n            var testMsg = new Unity.Robotics.ROSTCPConnector.MessageTypes.Std.StringMsg\n            {\n                data = $"test_{Time.time}_{messagesSent}"\n            };\n\n            communicationManager.SendToROS(testTopic, testMsg);\n            messagesSent++;\n\n            yield return new WaitForSeconds(testInterval);\n        }\n\n        EndValidationTest();\n    }\n\n    private void OnEchoReceived(Unity.Robotics.ROSTCPConnector.MessageTypes.Std.StringMsg msg)\n    {\n        messagesReceived++;\n        // Calculate round trip time if possible\n    }\n\n    private void EndValidationTest()\n    {\n        isTesting = false;\n\n        Debug.Log($"Communication Validation Results:\\n" +\n                 $"Duration: {testDuration}s\\n" +\n                 $"Messages Sent: {messagesSent}\\n" +\n                 $"Messages Received: {messagesReceived}\\n" +\n                 $"Success Rate: {(messagesReceived > 0 ? (float)messagesReceived / messagesSent * 100 : 0):F1}%");\n    }\n\n    public void StopValidationTest()\n    {\n        isTesting = false;\n    }\n\n    void OnValidate()\n    {\n        testDuration = Mathf.Clamp(testDuration, 1.0f, 60.0f);\n        testInterval = Mathf.Clamp(testInterval, 0.01f, 1.0f);\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"Now that you have implemented comprehensive ROS communication in Unity for humanoid robots, you can integrate these components into your digital twin system. The communication layer provides the foundation for real-time synchronization between Unity and ROS 2, enabling realistic simulation and control of humanoid robots."}),"\n",(0,o.jsx)(e.p,{children:"In the next section, we'll explore sensor simulation in Unity, covering how to create realistic sensor data for cameras, LiDAR, IMU, and other sensors commonly used in humanoid robotics applications."})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(m,{...n})}):m(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>s});var t=i(6540);const o={},a=t.createContext(o);function r(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);