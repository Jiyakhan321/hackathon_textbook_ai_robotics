"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6114],{4344:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1-robotic-nervous-system/python-agents/creating-nodes","title":"Creating Specialized ROS 2 Nodes","description":"Overview","source":"@site/docs/module-1-robotic-nervous-system/python-agents/creating-nodes.md","sourceDirName":"module-1-robotic-nervous-system/python-agents","slug":"/module-1-robotic-nervous-system/python-agents/creating-nodes","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/python-agents/creating-nodes","draft":false,"unlisted":false,"editUrl":"https://github.com/Jiyakhan321/hackathon_textbook_ai_robotics/tree/main/docs/module-1-robotic-nervous-system/python-agents/creating-nodes.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"rclpy Basics: Python Client Library for ROS 2","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/python-agents/rclpy-basics"},"next":{"title":"Publishers and Subscribers in Humanoid Robotics","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/python-agents/publishers-subscribers"}}');var t=s(4848),i=s(8453);const r={sidebar_position:2},l="Creating Specialized ROS 2 Nodes",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Types of Nodes in Humanoid Robotics",id:"types-of-nodes-in-humanoid-robotics",level:2},{value:"1. Sensor Nodes",id:"1-sensor-nodes",level:3},{value:"2. Controller Nodes",id:"2-controller-nodes",level:3},{value:"3. Perception Nodes",id:"3-perception-nodes",level:3},{value:"Node Composition",id:"node-composition",level:2},{value:"Node Configuration and Parameters",id:"node-configuration-and-parameters",level:2},{value:"Best Practices for Node Creation",id:"best-practices-for-node-creation",level:2},{value:"1. Proper Error Handling",id:"1-proper-error-handling",level:3},{value:"2. Resource Management",id:"2-resource-management",level:3},{value:"3. Logging Best Practices",id:"3-logging-best-practices",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"creating-specialized-ros-2-nodes",children:"Creating Specialized ROS 2 Nodes"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"In this section, we'll explore how to create specialized types of ROS 2 nodes for humanoid robot applications. We'll cover different node types, their purposes, and implementation patterns."}),"\n",(0,t.jsx)(n.h2,{id:"types-of-nodes-in-humanoid-robotics",children:"Types of Nodes in Humanoid Robotics"}),"\n",(0,t.jsx)(n.h3,{id:"1-sensor-nodes",children:"1. Sensor Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Sensor nodes are responsible for reading data from various sensors on the humanoid robot."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, LaserScan\nfrom std_msgs.msg import Header\nimport numpy as np\n\nclass HumanoidSensorNode(Node):\n    def __init__(self):\n        super().__init__('humanoid_sensor_node')\n\n        # Publishers for different sensor data\n        self.joint_pub = self.create_publisher(JointState, 'joint_states', 10)\n        self.imu_pub = self.create_publisher(Imu, 'imu/data', 10)\n        self.laser_pub = self.create_publisher(LaserScan, 'scan', 10)\n\n        # Timer for sensor reading\n        self.sensor_timer = self.create_timer(0.01, self.read_sensors)  # 100 Hz\n\n        # Initialize sensor data\n        self.joint_names = [\n            'left_hip', 'left_knee', 'left_ankle',\n            'right_hip', 'right_knee', 'right_ankle',\n            'left_shoulder', 'left_elbow', 'left_wrist',\n            'right_shoulder', 'right_elbow', 'right_wrist'\n        ]\n        self.joint_positions = [0.0] * len(self.joint_names)\n        self.joint_velocities = [0.0] * len(self.joint_names)\n        self.joint_efforts = [0.0] * len(self.joint_names)\n\n    def read_sensors(self):\n        \"\"\"Simulate reading sensor data from hardware\"\"\"\n        # Update joint positions with simulated data\n        for i in range(len(self.joint_positions)):\n            self.joint_positions[i] += 0.01 * np.sin(self.get_clock().now().nanoseconds * 1e-9)\n\n        # Publish joint states\n        self.publish_joint_states()\n\n        # Publish IMU data\n        self.publish_imu_data()\n\n        # Publish laser scan data\n        self.publish_laser_scan()\n\n    def publish_joint_states(self):\n        msg = JointState()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n        msg.name = self.joint_names\n        msg.position = self.joint_positions\n        msg.velocity = self.joint_velocities\n        msg.effort = self.joint_efforts\n        self.joint_pub.publish(msg)\n\n    def publish_imu_data(self):\n        msg = Imu()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'imu_link'\n        # Simulate IMU data\n        msg.orientation.w = 1.0\n        self.imu_pub.publish(msg)\n\n    def publish_laser_scan(self):\n        msg = LaserScan()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'laser_link'\n        msg.angle_min = -1.57  # -90 degrees\n        msg.angle_max = 1.57   # 90 degrees\n        msg.angle_increment = 0.01\n        msg.range_min = 0.1\n        msg.range_max = 10.0\n        msg.ranges = [2.0] * 314  # 314 points\n        self.laser_pub.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidSensorNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-controller-nodes",children:"2. Controller Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Controller nodes implement control algorithms for robot joints and actuators."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.msg import JointTrajectoryControllerState\nimport numpy as np\n\nclass HumanoidControllerNode(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_controller\')\n\n        # Subscriptions\n        self.joint_state_sub = self.create_subscription(\n            JointState, \'joint_states\', self.joint_state_callback, 10)\n\n        self.trajectory_sub = self.create_subscription(\n            JointTrajectory, \'joint_trajectory\', self.trajectory_callback, 10)\n\n        # Publishers\n        self.controller_state_pub = self.create_publisher(\n            JointTrajectoryControllerState, \'controller_state\', 10)\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.001, self.control_loop)  # 1 kHz\n\n        # Initialize controller state\n        self.current_joint_positions = {}\n        self.current_joint_velocities = {}\n        self.current_joint_efforts = {}\n        self.desired_joint_positions = {}\n        self.desired_joint_velocities = {}\n        self.desired_joint_efforts = {}\n\n        # PID controller parameters\n        self.kp = 100.0  # Proportional gain\n        self.ki = 0.1    # Integral gain\n        self.kd = 10.0   # Derivative gain\n\n    def joint_state_callback(self, msg):\n        """Update current joint states"""\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.current_joint_positions[name] = msg.position[i]\n            if i < len(msg.velocity):\n                self.current_joint_velocities[name] = msg.velocity[i]\n            if i < len(msg.effort):\n                self.current_joint_efforts[name] = msg.effort[i]\n\n    def trajectory_callback(self, msg):\n        """Receive trajectory commands"""\n        if len(msg.points) > 0:\n            # Get the last point in the trajectory\n            last_point = msg.points[-1]\n            for i, name in enumerate(msg.joint_names):\n                if i < len(last_point.positions):\n                    self.desired_joint_positions[name] = last_point.positions[i]\n                if i < len(last_point.velocities):\n                    self.desired_joint_velocities[name] = last_point.velocities[i]\n                if i < len(last_point.effort):\n                    self.desired_joint_efforts[name] = last_point.effort[i]\n\n    def control_loop(self):\n        """Main control loop implementing PID control"""\n        control_commands = {}\n\n        for joint_name in self.current_joint_positions:\n            current_pos = self.current_joint_positions[joint_name]\n            desired_pos = self.desired_joint_positions.get(joint_name, current_pos)\n\n            # Simple PID control\n            error = desired_pos - current_pos\n            control_output = self.kp * error\n\n            control_commands[joint_name] = control_output\n\n        # Publish controller state\n        self.publish_controller_state()\n\n    def publish_controller_state(self):\n        msg = JointTrajectoryControllerState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'base_link\'\n\n        # Fill in joint names\n        msg.joint_names = list(self.current_joint_positions.keys())\n\n        # Fill in desired states\n        for joint_name in msg.joint_names:\n            desired_point = JointTrajectoryPoint()\n            desired_point.positions = [self.desired_joint_positions.get(joint_name, 0.0)]\n            desired_point.velocities = [self.desired_joint_velocities.get(joint_name, 0.0)]\n            desired_point.accelerations = [0.0]  # Simplified\n            msg.desired.points.append(desired_point)\n\n        self.controller_state_pub.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidControllerNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-perception-nodes",children:"3. Perception Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Perception nodes process sensor data to extract meaningful information."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, PointCloud2\nfrom geometry_msgs.msg import PointStamped\nfrom std_msgs.msg import Header\nimport numpy as np\n\nclass HumanoidPerceptionNode(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_perception\')\n\n        # Subscriptions\n        self.image_sub = self.create_subscription(\n            Image, \'camera/image_raw\', self.image_callback, 10)\n\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2, \'pointcloud\', self.pointcloud_callback, 10)\n\n        # Publishers\n        self.object_pub = self.create_publisher(\n            PointStamped, \'detected_object\', 10)\n\n        # Timer for processing\n        self.process_timer = self.create_timer(0.1, self.process_data)  # 10 Hz\n\n        # Data storage\n        self.latest_image = None\n        self.latest_pointcloud = None\n        self.detected_objects = []\n\n    def image_callback(self, msg):\n        """Process incoming image data"""\n        self.latest_image = msg\n        # In a real implementation, you would convert ROS Image to OpenCV format\n        # and perform computer vision processing\n\n    def pointcloud_callback(self, msg):\n        """Process incoming point cloud data"""\n        self.latest_pointcloud = msg\n        # In a real implementation, you would process the point cloud data\n        # to detect objects, planes, etc.\n\n    def process_data(self):\n        """Main processing function"""\n        if self.latest_image is not None:\n            # Simulate object detection\n            if np.random.random() > 0.8:  # 20% chance of detection\n                self.detect_object()\n\n    def detect_object(self):\n        """Simulate object detection"""\n        # Create a detected object at a random position\n        obj = PointStamped()\n        obj.header = Header()\n        obj.header.stamp = self.get_clock().now().to_msg()\n        obj.header.frame_id = \'camera_frame\'\n\n        # Random position in front of robot\n        obj.point.x = 1.0 + np.random.uniform(-0.2, 0.2)\n        obj.point.y = np.random.uniform(-0.5, 0.5)\n        obj.point.z = np.random.uniform(0.0, 1.0)\n\n        self.detected_objects.append(obj)\n        self.object_pub.publish(obj)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidPerceptionNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"node-composition",children:"Node Composition"}),"\n",(0,t.jsx)(n.p,{children:"For complex humanoid systems, you can compose multiple nodes together:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom rclpy.executors import SingleThreadedExecutor\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import String\n\nclass HumanoidSystemNode(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_system\')\n\n        # Create callback groups for different components\n        self.sensors_cb_group = MutuallyExclusiveCallbackGroup()\n        self.control_cb_group = MutuallyExclusiveCallbackGroup()\n\n        # Publishers\n        self.status_pub = self.create_publisher(String, \'system_status\', 10)\n        self.joint_pub = self.create_publisher(JointState, \'joint_states\', 10)\n\n        # Timer for system monitoring\n        self.system_timer = self.create_timer(\n            1.0, self.system_monitor, callback_group=self.sensors_cb_group)\n\n        # Initialize system components\n        self.initialize_components()\n\n    def initialize_components(self):\n        """Initialize various system components"""\n        self.get_logger().info(\'Initializing humanoid system components...\')\n\n        # Initialize sensors\n        self.initialize_sensors()\n\n        # Initialize controllers\n        self.initialize_controllers()\n\n        # Initialize perception\n        self.initialize_perception()\n\n    def initialize_sensors(self):\n        """Initialize sensor components"""\n        self.get_logger().info(\'Sensors initialized\')\n\n    def initialize_controllers(self):\n        """Initialize controller components"""\n        self.get_logger().info(\'Controllers initialized\')\n\n    def initialize_perception(self):\n        """Initialize perception components"""\n        self.get_logger().info(\'Perception initialized\')\n\n    def system_monitor(self):\n        """Monitor system status"""\n        msg = String()\n        msg.data = f\'System running at {self.get_clock().now().nanoseconds * 1e-9:.2f}s\'\n        self.status_pub.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidSystemNode()\n\n    # Create executor and add the node\n    executor = SingleThreadedExecutor()\n    executor.add_node(node)\n\n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"node-configuration-and-parameters",children:"Node Configuration and Parameters"}),"\n",(0,t.jsx)(n.p,{children:"Properly configure nodes using parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rclpy.qos import QoSProfile\n\nclass ConfigurableHumanoidNode(Node):\n    def __init__(self):\n        super().__init__('configurable_humanoid')\n\n        # Declare parameters with descriptions and ranges\n        self.declare_parameter(\n            'robot_name',\n            'default_humanoid',\n            ParameterDescriptor(description='Name of the humanoid robot')\n        )\n\n        self.declare_parameter(\n            'control_frequency',\n            100,  # Hz\n            ParameterDescriptor(\n                description='Control loop frequency',\n                integer_range=[10, 1000]\n            )\n        )\n\n        self.declare_parameter(\n            'safety_limits.enabled',\n            True,\n            ParameterDescriptor(description='Enable safety limits')\n        )\n\n        self.declare_parameter(\n            'safety_limits.max_velocity',\n            2.0,\n            ParameterDescriptor(\n                description='Maximum joint velocity limit',\n                floating_point_range=[0.1, 10.0]\n            )\n        )\n\n        # Get parameter values\n        self.robot_name = self.get_parameter('robot_name').value\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.safety_enabled = self.get_parameter('safety_limits.enabled').value\n        self.max_velocity = self.get_parameter('safety_limits.max_velocity').value\n\n        # Set up QoS profiles based on parameters\n        qos_depth = self.get_parameter_or('qos_depth', Parameter('qos_depth', Parameter.Type.INTEGER, 10))\n\n        # Create publisher with configurable QoS\n        qos_profile = QoSProfile(depth=qos_depth.value)\n        self.status_pub = self.create_publisher(String, 'robot_status', qos_profile)\n\n        # Create timer based on frequency parameter\n        timer_period = 1.0 / self.control_frequency\n        self.control_timer = self.create_timer(timer_period, self.control_callback)\n\n        self.get_logger().info(\n            f'Configured {self.robot_name} with control frequency {self.control_frequency}Hz'\n        )\n\n    def control_callback(self):\n        \"\"\"Control callback that respects parameters\"\"\"\n        if self.safety_enabled:\n            # Apply safety checks based on parameters\n            if self.check_safety_limits():\n                self.execute_control()\n            else:\n                self.get_logger().warn('Safety limits exceeded, stopping control')\n        else:\n            self.execute_control()\n\n    def check_safety_limits(self):\n        \"\"\"Check if current state respects safety limits\"\"\"\n        # Implement safety checks based on parameters\n        return True\n\n    def execute_control(self):\n        \"\"\"Execute control logic\"\"\"\n        self.get_logger().info('Executing control command')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ConfigurableHumanoidNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-for-node-creation",children:"Best Practices for Node Creation"}),"\n",(0,t.jsx)(n.h3,{id:"1-proper-error-handling",children:"1. Proper Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def create_robust_publisher(self, msg_type, topic_name, qos_profile=10):\n    try:\n        publisher = self.create_publisher(msg_type, topic_name, qos_profile)\n        self.get_logger().info(f'Successfully created publisher for {topic_name}')\n        return publisher\n    except Exception as e:\n        self.get_logger().error(f'Failed to create publisher for {topic_name}: {e}')\n        return None\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-resource-management",children:"2. Resource Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def destroy_node(self):\n    # Clean up all created resources\n    if hasattr(self, 'publishers'):\n        for pub in self.publishers:\n            self.destroy_publisher(pub)\n\n    if hasattr(self, 'subscribers'):\n        for sub in self.subscribers:\n            self.destroy_subscription(sub)\n\n    if hasattr(self, 'timers'):\n        for timer in self.timers:\n            self.destroy_timer(timer)\n\n    if hasattr(self, 'clients'):\n        for client in self.clients:\n            self.destroy_client(client)\n\n    if hasattr(self, 'services'):\n        for service in self.services:\n            self.destroy_service(service)\n\n    return super().destroy_node()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-logging-best-practices",children:"3. Logging Best Practices"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def log_system_event(self, event_type, message, details=None):\n    \"\"\"Consistent logging for system events\"\"\"\n    if details:\n        log_msg = f'[{event_type}] {message} - Details: {details}'\n    else:\n        log_msg = f'[{event_type}] {message}'\n\n    if event_type in ['ERROR', 'CRITICAL']:\n        self.get_logger().error(log_msg)\n    elif event_type in ['WARNING', 'WARN']:\n        self.get_logger().warn(log_msg)\n    else:\n        self.get_logger().info(log_msg)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(n.p,{children:"Now that you understand how to create specialized nodes, let's look at publishers and subscribers in more detail, particularly for humanoid robot applications."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);