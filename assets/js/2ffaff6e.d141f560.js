"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7327],{6830:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1-robotic-nervous-system/python-agents/publishers-subscribers","title":"Publishers and Subscribers in Humanoid Robotics","description":"Overview","source":"@site/docs/module-1-robotic-nervous-system/python-agents/publishers-subscribers.md","sourceDirName":"module-1-robotic-nervous-system/python-agents","slug":"/module-1-robotic-nervous-system/python-agents/publishers-subscribers","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/python-agents/publishers-subscribers","draft":false,"unlisted":false,"editUrl":"https://github.com/Jiyakhan321/hackathon_textbook_ai_robotics/tree/main/docs/module-1-robotic-nervous-system/python-agents/publishers-subscribers.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Creating Specialized ROS 2 Nodes","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/python-agents/creating-nodes"},"next":{"title":"URDF Syntax and Structure","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/urdf-modeling/urdf-syntax"}}');var i=s(4848),r=s(8453);const o={sidebar_position:3},a="Publishers and Subscribers in Humanoid Robotics",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Publisher-Subscriber Pattern in Humanoid Systems",id:"publisher-subscriber-pattern-in-humanoid-systems",level:2},{value:"Basic Publisher Implementation",id:"basic-publisher-implementation",level:2},{value:"Advanced Publisher with Multiple Topics",id:"advanced-publisher-with-multiple-topics",level:2},{value:"Basic Subscriber Implementation",id:"basic-subscriber-implementation",level:2},{value:"Advanced Multi-Topic Subscriber",id:"advanced-multi-topic-subscriber",level:2},{value:"Quality of Service (QoS) Considerations",id:"quality-of-service-qos-considerations",level:2},{value:"Publisher-Subscriber Best Practices",id:"publisher-subscriber-best-practices",level:2},{value:"1. Proper Resource Management",id:"1-proper-resource-management",level:3},{value:"2. Data Validation",id:"2-data-validation",level:3},{value:"3. Error Handling",id:"3-error-handling",level:3},{value:"Next Steps",id:"next-steps",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"publishers-and-subscribers-in-humanoid-robotics",children:"Publishers and Subscribers in Humanoid Robotics"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Publishers and subscribers form the backbone of ROS 2 communication, enabling the asynchronous exchange of information between different components of a humanoid robot system. In this section, we'll explore how to effectively use publishers and subscribers for various humanoid robot applications."}),"\n",(0,i.jsx)(n.h2,{id:"publisher-subscriber-pattern-in-humanoid-systems",children:"Publisher-Subscriber Pattern in Humanoid Systems"}),"\n",(0,i.jsx)(n.p,{children:"The publisher-subscriber pattern is particularly useful in humanoid robotics because it allows for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Decoupling of components (sensors, controllers, perception systems)"}),"\n",(0,i.jsx)(n.li,{children:"Flexible system architecture"}),"\n",(0,i.jsx)(n.li,{children:"Real-time data exchange"}),"\n",(0,i.jsx)(n.li,{children:"Multiple consumers of the same data"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-publisher-implementation",children:"Basic Publisher Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Let's start with a basic joint state publisher for humanoid robots:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nimport math\nimport time\n\nclass JointStatePublisher(Node):\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n\n        # Create publisher for joint states\n        self.publisher = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Timer for publishing joint states at regular intervals\n        self.timer = self.create_timer(0.05, self.publish_joint_states)  # 20 Hz\n\n        # Initialize joint information\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint'\n        ]\n\n        # Initialize positions with zero values\n        self.joint_positions = [0.0] * len(self.joint_names)\n        self.joint_velocities = [0.0] * len(self.joint_names)\n        self.joint_efforts = [0.0] * len(self.joint_names)\n\n        self.get_logger().info('Joint state publisher initialized')\n\n    def publish_joint_states(self):\n        \"\"\"Publish joint state information\"\"\"\n        msg = JointState()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n\n        msg.name = self.joint_names\n        msg.position = self.update_joint_positions()\n        msg.velocity = self.joint_velocities\n        msg.effort = self.joint_efforts\n\n        self.publisher.publish(msg)\n        self.get_logger().debug(f'Published joint states: {len(msg.name)} joints')\n\n    def update_joint_positions(self):\n        \"\"\"Update joint positions based on time for demonstration\"\"\"\n        current_time = self.get_clock().now().nanoseconds * 1e-9  # Convert to seconds\n\n        # Create a simple oscillating pattern for demonstration\n        for i in range(len(self.joint_positions)):\n            # Different oscillation patterns for different joints\n            amplitude = 0.5 if i % 2 == 0 else 0.3\n            frequency = 0.5 + (i % 3) * 0.2\n            self.joint_positions[i] = amplitude * math.sin(frequency * current_time + i)\n\n        return self.joint_positions\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = JointStatePublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-publisher-with-multiple-topics",children:"Advanced Publisher with Multiple Topics"}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots, you often need to publish to multiple topics simultaneously:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, Temperature\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64MultiArray, Bool\nimport numpy as np\n\nclass MultiTopicPublisher(Node):\n    def __init__(self):\n        super().__init__(\'multi_topic_publisher\')\n\n        # Multiple publishers for different data types\n        self.joint_pub = self.create_publisher(JointState, \'joint_states\', 10)\n        self.imu_pub = self.create_publisher(Imu, \'imu/data\', 10)\n        self.temperature_pub = self.create_publisher(Temperature, \'temperature\', 10)\n        self.motor_current_pub = self.create_publisher(Float64MultiArray, \'motor_currents\', 10)\n        self.emergency_stop_pub = self.create_publisher(Bool, \'emergency_stop\', 10)\n\n        # Timer for coordinated publishing\n        self.publish_timer = self.create_timer(0.01, self.publish_all_data)  # 100 Hz\n\n        # Initialize data\n        self.joint_names = [f\'joint_{i}\' for i in range(12)]\n        self.time_offset = self.get_clock().now().nanoseconds * 1e-9\n\n        self.get_logger().info(\'Multi-topic publisher initialized\')\n\n    def publish_all_data(self):\n        """Publish all types of data in a coordinated manner"""\n        current_time = self.get_clock().now().nanoseconds * 1e-9\n\n        # Publish joint states\n        self.publish_joint_states(current_time)\n\n        # Publish IMU data\n        self.publish_imu_data(current_time)\n\n        # Publish temperature data\n        self.publish_temperature_data(current_time)\n\n        # Publish motor currents\n        self.publish_motor_currents(current_time)\n\n        # Check and publish emergency stop if needed\n        self.check_and_publish_emergency_stop(current_time)\n\n    def publish_joint_states(self, current_time):\n        """Publish joint state information"""\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'base_link\'\n        msg.name = self.joint_names\n\n        # Generate time-varying joint positions\n        positions = [0.5 * np.sin(2 * np.pi * 0.5 * (current_time - self.time_offset) + i)\n                     for i in range(len(self.joint_names))]\n        msg.position = positions\n\n        velocities = [np.cos(2 * np.pi * 0.5 * (current_time - self.time_offset) + i)\n                      for i in range(len(self.joint_names))]\n        msg.velocity = velocities\n\n        efforts = [0.1 * np.sin(4 * np.pi * 0.5 * (current_time - self.time_offset) + i)\n                   for i in range(len(self.joint_names))]\n        msg.effort = efforts\n\n        self.joint_pub.publish(msg)\n\n    def publish_imu_data(self, current_time):\n        """Publish IMU sensor data"""\n        msg = Imu()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'imu_link\'\n\n        # Simulate IMU orientation (simplified)\n        msg.orientation.w = np.cos(0.1 * current_time)\n        msg.orientation.x = np.sin(0.1 * current_time) * 0.1\n        msg.orientation.y = np.sin(0.1 * current_time) * 0.05\n        msg.orientation.z = 0.0\n\n        # Simulate angular velocity\n        msg.angular_velocity.x = 0.1 * np.cos(0.1 * current_time)\n        msg.angular_velocity.y = 0.05 * np.sin(0.1 * current_time)\n        msg.angular_velocity.z = 0.02 * np.sin(0.2 * current_time)\n\n        # Simulate linear acceleration\n        msg.linear_acceleration.x = 9.81 * np.sin(0.1 * current_time)\n        msg.linear_acceleration.y = 0.1 * np.cos(0.1 * current_time)\n        msg.linear_acceleration.z = 9.81 * np.cos(0.1 * current_time)\n\n        self.imu_pub.publish(msg)\n\n    def publish_temperature_data(self, current_time):\n        """Publish temperature sensor data"""\n        msg = Temperature()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'thermal_sensor\'\n        msg.temperature = 25.0 + 5.0 * np.sin(0.05 * current_time)  # Varying temperature\n        msg.variance = 0.1  # Small variance\n\n        self.temperature_pub.publish(msg)\n\n    def publish_motor_currents(self, current_time):\n        """Publish motor current information"""\n        msg = Float64MultiArray()\n        # Simulate motor currents for each joint\n        currents = [0.5 + 0.2 * np.sin(0.2 * current_time + i)\n                    for i in range(len(self.joint_names))]\n        msg.data = currents\n\n        self.motor_current_pub.publish(msg)\n\n    def check_and_publish_emergency_stop(self, current_time):\n        """Check conditions and publish emergency stop if needed"""\n        # Simulate emergency stop based on some condition\n        emergency = False  # In real system, check actual conditions\n\n        msg = Bool()\n        msg.data = emergency\n        self.emergency_stop_pub.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MultiTopicPublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"basic-subscriber-implementation",children:"Basic Subscriber Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Now let's look at how to implement subscribers that can handle data from humanoid robot systems:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64MultiArray, Bool\nimport numpy as np\n\nclass JointStateSubscriber(Node):\n    def __init__(self):\n        super().__init__('joint_state_subscriber')\n\n        # Subscribe to joint states\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Store latest joint state\n        self.latest_joint_state = None\n        self.joint_state_received = False\n\n        # Timer to process data periodically\n        self.process_timer = self.create_timer(1.0, self.process_joint_data)\n\n        self.get_logger().info('Joint state subscriber initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Callback for receiving joint state messages\"\"\"\n        self.latest_joint_state = msg\n        self.joint_state_received = True\n\n        # Log received data\n        self.get_logger().debug(f'Received joint state with {len(msg.name)} joints')\n\n    def process_joint_data(self):\n        \"\"\"Process joint data periodically\"\"\"\n        if self.joint_state_received and self.latest_joint_state:\n            # Analyze joint positions\n            avg_position = np.mean(self.latest_joint_state.position)\n            max_position = np.max(np.abs(self.latest_joint_state.position))\n\n            self.get_logger().info(\n                f'Joint state analysis - Avg pos: {avg_position:.3f}, Max abs pos: {max_position:.3f}'\n            )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = JointStateSubscriber()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-multi-topic-subscriber",children:"Advanced Multi-Topic Subscriber"}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots, you often need to subscribe to multiple topics and correlate the data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64MultiArray, Bool\nimport numpy as np\nfrom collections import deque\nimport time\n\nclass HumanoidDataProcessor(Node):\n    def __init__(self):\n        super().__init__('humanoid_data_processor')\n\n        # Multiple subscriptions\n        self.joint_sub = self.create_subscription(\n            JointState, 'joint_states', self.joint_callback, 10)\n\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback, 10)\n\n        self.motor_current_sub = self.create_subscription(\n            Float64MultiArray, 'motor_currents', self.motor_current_callback, 10)\n\n        self.emergency_stop_sub = self.create_subscription(\n            Bool, 'emergency_stop', self.emergency_stop_callback, 10)\n\n        # Data storage with time stamps\n        self.joint_buffer = deque(maxlen=100)  # Store last 100 joint states\n        self.imu_buffer = deque(maxlen=100)    # Store last 100 IMU readings\n        self.current_buffer = deque(maxlen=100) # Store last 100 current readings\n\n        # State variables\n        self.emergency_stop_active = False\n        self.last_joint_update = 0\n        self.last_imu_update = 0\n\n        # Processing timer\n        self.process_timer = self.create_timer(0.1, self.process_sensor_data)  # 10 Hz\n\n        self.get_logger().info('Humanoid data processor initialized')\n\n    def joint_callback(self, msg):\n        \"\"\"Handle joint state messages\"\"\"\n        timestamp = self.get_clock().now().nanoseconds * 1e-9\n        self.joint_buffer.append({\n            'timestamp': timestamp,\n            'msg': msg\n        })\n        self.last_joint_update = timestamp\n\n    def imu_callback(self, msg):\n        \"\"\"Handle IMU messages\"\"\"\n        timestamp = self.get_clock().now().nanoseconds * 1e-9\n        self.imu_buffer.append({\n            'timestamp': timestamp,\n            'msg': msg\n        })\n        self.last_imu_update = timestamp\n\n    def motor_current_callback(self, msg):\n        \"\"\"Handle motor current messages\"\"\"\n        timestamp = self.get_clock().now().nanoseconds * 1e-9\n        self.current_buffer.append({\n            'timestamp': timestamp,\n            'data': msg.data\n        })\n\n    def emergency_stop_callback(self, msg):\n        \"\"\"Handle emergency stop messages\"\"\"\n        self.emergency_stop_active = msg.data\n        if self.emergency_stop_active:\n            self.get_logger().warn('EMERGENCY STOP ACTIVATED!')\n\n    def process_sensor_data(self):\n        \"\"\"Process all sensor data and extract meaningful information\"\"\"\n        if not self.joint_buffer or not self.imu_buffer:\n            return\n\n        # Get latest data\n        latest_joint = self.joint_buffer[-1]\n        latest_imu = self.imu_buffer[-1]\n\n        # Calculate joint velocity estimates from position changes\n        if len(self.joint_buffer) > 1:\n            prev_joint = self.joint_buffer[-2]\n            dt = latest_joint['timestamp'] - prev_joint['timestamp']\n            if dt > 0:\n                position_diff = np.array(latest_joint['msg'].position) - np.array(prev_joint['msg'].position)\n                estimated_velocities = position_diff / dt\n\n                # Log max velocity\n                max_vel = np.max(np.abs(estimated_velocities))\n                if max_vel > 10.0:  # Threshold for logging\n                    self.get_logger().info(f'High joint velocity detected: {max_vel:.3f} rad/s')\n\n        # Analyze IMU data for stability\n        imu_msg = latest_imu['msg']\n        linear_accel = np.sqrt(\n            imu_msg.linear_acceleration.x**2 +\n            imu_msg.linear_acceleration.y**2 +\n            imu_msg.linear_acceleration.z**2\n        )\n\n        # Check if robot is stable based on IMU\n        if abs(linear_accel - 9.81) > 2.0:  # Deviation from gravity\n            self.get_logger().info(f'Potential instability detected: accel={linear_accel:.2f}')\n\n        # Analyze motor currents for anomalies\n        if self.current_buffer:\n            latest_currents = self.current_buffer[-1]['data']\n            avg_current = np.mean(latest_currents)\n            max_current = np.max(latest_currents)\n\n            if max_current > 5.0:  # High current threshold\n                self.get_logger().warn(f'High motor current detected: {max_current:.2f}A')\n\n        # Check for data staleness\n        current_time = self.get_clock().now().nanoseconds * 1e-9\n        if current_time - self.last_joint_update > 1.0:\n            self.get_logger().warn('Joint state data is stale (>1 second)')\n        if current_time - self.last_imu_update > 1.0:\n            self.get_logger().warn('IMU data is stale (>1 second)')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidDataProcessor()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"quality-of-service-qos-considerations",children:"Quality of Service (QoS) Considerations"}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robotics applications, QoS settings are crucial for reliable communication:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy\n\nclass QoSHumanoidNode(Node):\n    def __init__(self):\n        super().__init__('qos_humanoid_node')\n\n        # Define different QoS profiles for different data types\n\n        # Joint states: need reliability and some history\n        joint_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # IMU data: need all messages for control\n        imu_qos = QoSProfile(\n            depth=50,  # Keep more IMU messages\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_ALL  # Keep all IMU messages for control\n        )\n\n        # Status messages: can be best effort\n        status_qos = QoSProfile(\n            depth=5,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # Create publishers with appropriate QoS\n        self.joint_pub = self.create_publisher(JointState, 'joint_states', joint_qos)\n        self.imu_pub = self.create_publisher(Imu, 'imu/data', imu_qos)\n        self.status_pub = self.create_publisher(String, 'status', status_qos)\n\n        # Create subscriptions with matching QoS\n        self.joint_sub = self.create_subscription(\n            JointState, 'joint_states', self.joint_callback, joint_qos)\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback, imu_qos)\n\n        self.get_logger().info('QoS-configured humanoid node initialized')\n\n    def joint_callback(self, msg):\n        \"\"\"Handle joint state messages with appropriate QoS\"\"\"\n        self.get_logger().debug(f'Received joint state with QoS')\n\n    def imu_callback(self, msg):\n        \"\"\"Handle IMU messages with appropriate QoS\"\"\"\n        self.get_logger().debug(f'Received IMU data with QoS')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = QoSHumanoidNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"publisher-subscriber-best-practices",children:"Publisher-Subscriber Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-proper-resource-management",children:"1. Proper Resource Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class BestPracticeNode(Node):\n    def __init__(self):\n        super().__init__('best_practice_node')\n\n        # Store references to all publishers/subscribers\n        self.publishers = {}\n        self.subscribers = {}\n\n        # Create publishers\n        self.publishers['joint_states'] = self.create_publisher(JointState, 'joint_states', 10)\n        self.publishers['imu_data'] = self.create_publisher(Imu, 'imu/data', 10)\n\n        # Create subscribers\n        self.subscribers['commands'] = self.create_subscription(\n            JointTrajectory, 'joint_trajectory', self.command_callback, 10)\n\n    def destroy_node(self):\n        \"\"\"Properly clean up all resources\"\"\"\n        for pub in self.publishers.values():\n            self.destroy_publisher(pub)\n\n        for sub in self.subscribers.values():\n            self.destroy_subscription(sub)\n\n        return super().destroy_node()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-data-validation",children:"2. Data Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def validate_joint_state(self, msg):\n    \"\"\"Validate joint state message before processing\"\"\"\n    if len(msg.name) != len(msg.position):\n        self.get_logger().error('Joint names and positions length mismatch')\n        return False\n\n    if len(msg.position) != len(msg.velocity) and len(msg.velocity) > 0:\n        self.get_logger().warn('Position-velocity length mismatch')\n\n    # Check for invalid values\n    for pos in msg.position:\n        if not (-100 < pos < 100):  # Reasonable joint limit\n            self.get_logger().warn(f'Unusual joint position: {pos}')\n            return False\n\n    return True\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-error-handling",children:"3. Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def safe_publish(self, publisher, msg):\n    """Safely publish a message with error handling"""\n    try:\n        publisher.publish(msg)\n        return True\n    except Exception as e:\n        self.get_logger().error(f\'Failed to publish message: {e}\')\n        return False\n'})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you understand publishers and subscribers, let's move on to URDF modeling for humanoid robots, which defines the physical structure that these communication systems will control."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(6540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);