"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9588],{2178:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-2-digital-twin/unity-simulation/environment-creation","title":"Environment Creation for Humanoid Robots in Unity","description":"Overview","source":"@site/docs/module-2-digital-twin/unity-simulation/environment-creation.md","sourceDirName":"module-2-digital-twin/unity-simulation","slug":"/module-2-digital-twin/unity-simulation/environment-creation","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/unity-simulation/environment-creation","draft":false,"unlisted":false,"editUrl":"https://github.com/Jiyakhan321/hackathon_textbook_ai_robotics/tree/main/docs/module-2-digital-twin/unity-simulation/environment-creation.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Unity Robotics Setup and Configuration","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/unity-simulation/unity-robotics-setup"},"next":{"title":"Unity-ROS Communication Implementation","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/unity-simulation/unity-ros-communication"}}');var o=t(4848),a=t(8453);const r={sidebar_position:2},s="Environment Creation for Humanoid Robots in Unity",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Unity Scene Architecture for Robotics",id:"unity-scene-architecture-for-robotics",level:2},{value:"1. Recommended Scene Structure",id:"1-recommended-scene-structure",level:3},{value:"2. Physics Layer Setup",id:"2-physics-layer-setup",level:3},{value:"Creating Humanoid-Friendly Environments",id:"creating-humanoid-friendly-environments",level:2},{value:"1. Indoor Environment",id:"1-indoor-environment",level:3},{value:"2. Outdoor Environment",id:"2-outdoor-environment",level:3},{value:"Physics Material Configuration",id:"physics-material-configuration",level:2},{value:"1. Creating Physics Materials",id:"1-creating-physics-materials",level:3},{value:"2. Terrain and Surface Variations",id:"2-terrain-and-surface-variations",level:3},{value:"Navigation and Waypoint Systems",id:"navigation-and-waypoint-systems",level:2},{value:"1. Waypoint Manager for Training",id:"1-waypoint-manager-for-training",level:3},{value:"Environment Testing and Validation",id:"environment-testing-and-validation",level:2},{value:"1. Environment Validation Script",id:"1-environment-validation-script",level:3},{value:"Next Steps",id:"next-steps",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"environment-creation-for-humanoid-robots-in-unity",children:"Environment Creation for Humanoid Robots in Unity"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Creating realistic environments in Unity is essential for effective humanoid robot simulation. Unlike Gazebo, Unity offers superior graphics capabilities and more flexible environment design, making it ideal for computer vision training, complex scene simulation, and visually rich testing scenarios. This section covers creating environments specifically designed for humanoid robot interaction."}),"\n",(0,o.jsx)(e.h2,{id:"unity-scene-architecture-for-robotics",children:"Unity Scene Architecture for Robotics"}),"\n",(0,o.jsx)(e.h3,{id:"1-recommended-scene-structure",children:"1. Recommended Scene Structure"}),"\n",(0,o.jsx)(e.p,{children:"For humanoid robot simulation, organize your scene with the following hierarchy:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Main Scene\n\u251c\u2500\u2500 Environment\n\u2502   \u251c\u2500\u2500 GroundPlane\n\u2502   \u251c\u2500\u2500 StaticObstacles\n\u2502   \u251c\u2500\u2500 InteractiveObjects\n\u2502   \u2514\u2500\u2500 Waypoints\n\u251c\u2500\u2500 HumanoidRobot\n\u2502   \u251c\u2500\u2500 RobotBase\n\u2502   \u251c\u2500\u2500 Sensors\n\u2502   \u2514\u2500\u2500 Controllers\n\u251c\u2500\u2500 Lighting\n\u2502   \u251c\u2500\u2500 DirectionalLight (sun)\n\u2502   \u251c\u2500\u2500 PointLights\n\u2502   \u2514\u2500\u2500 ReflectionProbes\n\u251c\u2500\u2500 Physics\n\u2502   \u251c\u2500\u2500 PhysicsMaterials\n\u2502   \u2514\u2500\u2500 CollisionLayers\n\u2514\u2500\u2500 Management\n    \u251c\u2500\u2500 ROSConnectionManager\n    \u251c\u2500\u2500 SimulationController\n    \u2514\u2500\u2500 DebugTools\n"})}),"\n",(0,o.jsx)(e.h3,{id:"2-physics-layer-setup",children:"2. Physics Layer Setup"}),"\n",(0,o.jsx)(e.p,{children:"Configure Unity's physics layers for humanoid robot interaction:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// PhysicsLayerManager.cs - Manage collision layers for humanoid simulation\n\nusing UnityEngine;\n\npublic class PhysicsLayerManager : MonoBehaviour\n{\n    [Header("Physics Layer Configuration")]\n    public LayerMask RobotLayer = 1 << 8;    // Layer 8: Robot\n    public LayerMask EnvironmentLayer = 1 << 9; // Layer 9: Environment\n    public LayerMask ObstacleLayer = 1 << 10;    // Layer 10: Obstacles\n    public LayerMask SensorLayer = 1 << 11;      // Layer 11: Sensors\n    public LayerMask InteractionLayer = 1 << 12; // Layer 12: Interactive objects\n\n    [Header("Collision Matrix")]\n    public bool RobotCollidesWithEnvironment = true;\n    public bool RobotCollidesWithObstacles = true;\n    public bool RobotCollidesWithSelf = false; // Usually false to prevent self-collision issues\n    public bool RobotSensorsCollideWithEnvironment = true;\n    public bool RobotSensorsCollideWithObstacles = true;\n\n    void Start()\n    {\n        ConfigurePhysicsLayers();\n    }\n\n    void ConfigurePhysicsLayers()\n    {\n        // Set up layer names (requires manual setup in Unity editor first)\n        SetupCollisionMatrix();\n    }\n\n    void SetupCollisionMatrix()\n    {\n        // Robot vs Environment\n        Physics.IgnoreLayerCollision(8, 9, !RobotCollidesWithEnvironment);\n\n        // Robot vs Obstacles\n        Physics.IgnoreLayerCollision(8, 10, !RobotCollidesWithObstacles);\n\n        // Robot vs Self (usually ignored to prevent self-collision issues)\n        Physics.IgnoreLayerCollision(8, 8, !RobotCollidesWithSelf);\n\n        // Sensors vs Environment\n        Physics.IgnoreLayerCollision(11, 9, !RobotSensorsCollideWithEnvironment);\n\n        // Sensors vs Obstacles\n        Physics.IgnoreLayerCollision(11, 10, !RobotSensorsCollideWithObstacles);\n\n        Debug.Log("Physics collision matrix configured for humanoid robot");\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"creating-humanoid-friendly-environments",children:"Creating Humanoid-Friendly Environments"}),"\n",(0,o.jsx)(e.h3,{id:"1-indoor-environment",children:"1. Indoor Environment"}),"\n",(0,o.jsx)(e.p,{children:"Let's create an indoor environment suitable for humanoid robot testing:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// IndoorEnvironment.cs - Generate indoor environment components\n\nusing UnityEngine;\nusing System.Collections.Generic;\n\npublic class IndoorEnvironment : MonoBehaviour\n{\n    [Header("Environment Dimensions")]\n    public Vector3 roomSize = new Vector3(20f, 8f, 20f);\n    public float wallThickness = 0.5f;\n    public float wallHeight = 4f;\n\n    [Header("Floor Settings")]\n    public PhysicMaterial floorMaterial;\n    public Color floorColor = Color.gray;\n\n    [Header("Furniture Configuration")]\n    public float tableHeight = 0.8f;\n    public float tableSize = 1.5f;\n    public int numTables = 3;\n\n    [Header("Obstacle Settings")]\n    public int numObstacles = 5;\n    public float obstacleMinSize = 0.5f;\n    public float obstacleMaxSize = 1.5f;\n\n    [Header("Door Settings")]\n    public float doorWidth = 1.0f;\n    public float doorHeight = 2.0f;\n\n    private List<GameObject> spawnedObjects = new List<GameObject>();\n\n    [ContextMenu("Generate Environment")]\n    public void GenerateEnvironment()\n    {\n        ClearEnvironment();\n        CreateRoom();\n        CreateFloor();\n        CreateFurniture();\n        CreateObstacles();\n        CreateDoors();\n        CreateWaypoints();\n    }\n\n    void ClearEnvironment()\n    {\n        foreach (GameObject obj in spawnedObjects)\n        {\n            if (obj != null)\n                DestroyImmediate(obj);\n        }\n        spawnedObjects.Clear();\n    }\n\n    void CreateRoom()\n    {\n        // Create walls using the room size\n        Vector3 center = transform.position;\n\n        // Front wall\n        CreateWall(center + new Vector3(0, wallHeight / 2, -roomSize.z / 2),\n                  new Vector3(roomSize.x, wallHeight, wallThickness));\n\n        // Back wall\n        CreateWall(center + new Vector3(0, wallHeight / 2, roomSize.z / 2),\n                  new Vector3(roomSize.x, wallHeight, wallThickness));\n\n        // Left wall\n        CreateWall(center + new Vector3(-roomSize.x / 2, wallHeight / 2, 0),\n                  new Vector3(wallThickness, wallHeight, roomSize.z));\n\n        // Right wall\n        CreateWall(center + new Vector3(roomSize.x / 2, wallHeight / 2, 0),\n                  new Vector3(wallThickness, wallHeight, roomSize.z));\n    }\n\n    GameObject CreateWall(Vector3 position, Vector3 size)\n    {\n        GameObject wall = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        wall.name = "Wall";\n        wall.transform.position = position;\n        wall.transform.localScale = size;\n        wall.layer = 9; // Environment layer\n\n        // Remove collider if it has one and add custom physics properties\n        DestroyImmediate(wall.GetComponent<BoxCollider>());\n        BoxCollider newCollider = wall.AddComponent<BoxCollider>();\n        newCollider.material = floorMaterial;\n\n        // Make static for optimization\n        wall.isStatic = true;\n\n        spawnedObjects.Add(wall);\n        return wall;\n    }\n\n    void CreateFloor()\n    {\n        GameObject floor = GameObject.CreatePrimitive(PrimitiveType.Plane);\n        floor.name = "Floor";\n        floor.transform.position = transform.position + new Vector3(0, -0.1f, 0); // Slightly below to avoid z-fighting\n        floor.transform.localScale = new Vector3(roomSize.x / 10f, 1, roomSize.z / 10f); // Plane primitive is 10x10 units\n        floor.layer = 9; // Environment layer\n\n        // Apply material\n        Renderer floorRenderer = floor.GetComponent<Renderer>();\n        if (floorRenderer != null)\n        {\n            floorRenderer.material.color = floorColor;\n        }\n\n        // Set physics material\n        floor.GetComponent<Collider>().material = floorMaterial;\n\n        // Make static for optimization\n        floor.isStatic = true;\n\n        spawnedObjects.Add(floor);\n    }\n\n    void CreateFurniture()\n    {\n        for (int i = 0; i < numTables; i++)\n        {\n            // Random position within room bounds\n            Vector3 tablePos = new Vector3(\n                Random.Range(-roomSize.x / 3, roomSize.x / 3),\n                tableHeight / 2,\n                Random.Range(-roomSize.z / 3, roomSize.z / 3)\n            ) + (Vector3)transform.position;\n\n            GameObject table = CreateTable(tablePos, tableSize);\n            table.layer = 10; // Obstacle layer\n            spawnedObjects.Add(table);\n        }\n    }\n\n    GameObject CreateTable(Vector3 position, float size)\n    {\n        // Create table top\n        GameObject tableTop = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        tableTop.name = "TableTop";\n        tableTop.transform.position = position;\n        tableTop.transform.localScale = new Vector3(size, 0.1f, size);\n        tableTop.layer = 10;\n\n        // Create table legs\n        float legHeight = tableHeight - 0.05f; // 5cm gap between top and floor\n        float legSize = 0.1f;\n        float legOffset = size / 2 - 0.1f;\n\n        // Four legs\n        CreateLeg(tableTop.transform, new Vector3(-legOffset, -legHeight / 2, -legOffset), legSize, legHeight);\n        CreateLeg(tableTop.transform, new Vector3(legOffset, -legHeight / 2, -legOffset), legSize, legHeight);\n        CreateLeg(tableTop.transform, new Vector3(-legOffset, -legHeight / 2, legOffset), legSize, legHeight);\n        CreateLeg(tableTop.transform, new Vector3(legOffset, -legHeight / 2, legOffset), legSize, legHeight);\n\n        // Make static for optimization\n        tableTop.isStatic = true;\n\n        return tableTop;\n    }\n\n    GameObject CreateLeg(Transform parent, Vector3 localPos, float size, float height)\n    {\n        GameObject leg = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        leg.name = "TableLeg";\n        leg.transform.SetParent(parent);\n        leg.transform.localPosition = localPos;\n        leg.transform.localScale = new Vector3(size, height, size);\n        leg.layer = 10;\n\n        // Remove the default collider and add a proper one\n        DestroyImmediate(leg.GetComponent<Collider>());\n        BoxCollider collider = leg.AddComponent<BoxCollider>();\n        collider.material = floorMaterial;\n\n        return leg;\n    }\n\n    void CreateObstacles()\n    {\n        for (int i = 0; i < numObstacles; i++)\n        {\n            // Random position within room\n            Vector3 obstaclePos = new Vector3(\n                Random.Range(-roomSize.x / 2 + 1, roomSize.x / 2 - 1),\n                Random.Range(0.2f, 2f), // Height off ground\n                Random.Range(-roomSize.z / 2 + 1, roomSize.z / 2 - 1)\n            ) + (Vector3)transform.position;\n\n            float obstacleSize = Random.Range(obstacleMinSize, obstacleMaxSize);\n\n            GameObject obstacle = GameObject.CreatePrimitive(PrimitiveType.Cube);\n            obstacle.name = $"Obstacle_{i}";\n            obstacle.transform.position = obstaclePos;\n            obstacle.transform.localScale = new Vector3(obstacleSize, obstacleSize, obstacleSize);\n            obstacle.layer = 10; // Obstacle layer\n\n            // Add physics material\n            obstacle.GetComponent<Collider>().material = floorMaterial;\n\n            // Add some visual variety\n            Renderer rend = obstacle.GetComponent<Renderer>();\n            if (rend != null)\n            {\n                rend.material.color = Random.ColorHSV(0f, 1f, 0.5f, 1f, 0.5f, 1f);\n            }\n\n            spawnedObjects.Add(obstacle);\n        }\n    }\n\n    void CreateDoors()\n    {\n        // Create a simple door opening in the front wall\n        Vector3 doorPos = new Vector3(transform.position.x, doorHeight / 2, transform.position.z - roomSize.z / 2);\n\n        // Create a frame around the door opening (not the actual door)\n        CreateDoorFrame(doorPos);\n    }\n\n    void CreateDoorFrame(Vector3 position)\n    {\n        float frameThickness = 0.2f;\n        float frameDepth = wallThickness;\n\n        // Top frame\n        GameObject topFrame = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        topFrame.name = "DoorFrame_Top";\n        topFrame.transform.position = position + new Vector3(0, doorHeight + frameThickness / 2, frameThickness / 2);\n        topFrame.transform.localScale = new Vector3(doorWidth, frameThickness, frameDepth);\n        topFrame.layer = 9;\n        topFrame.isStatic = true;\n        spawnedObjects.Add(topFrame);\n\n        // Side frames\n        GameObject leftFrame = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        leftFrame.name = "DoorFrame_Left";\n        leftFrame.transform.position = position + new Vector3(-doorWidth / 2 - frameThickness / 2, doorHeight / 2, frameThickness / 2);\n        leftFrame.transform.localScale = new Vector3(frameThickness, doorHeight, frameDepth);\n        leftFrame.layer = 9;\n        leftFrame.isStatic = true;\n        spawnedObjects.Add(leftFrame);\n\n        GameObject rightFrame = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        rightFrame.name = "DoorFrame_Right";\n        rightFrame.transform.position = position + new Vector3(doorWidth / 2 + frameThickness / 2, doorHeight / 2, frameThickness / 2);\n        rightFrame.transform.localScale = new Vector3(frameThickness, doorHeight, frameDepth);\n        rightFrame.layer = 9;\n        rightFrame.isStatic = true;\n        spawnedObjects.Add(rightFrame);\n    }\n\n    void CreateWaypoints()\n    {\n        // Create waypoints for navigation testing\n        for (int i = 0; i < 5; i++)\n        {\n            GameObject waypoint = new GameObject($"Waypoint_{i}");\n            waypoint.transform.position = new Vector3(\n                Random.Range(-roomSize.x / 4, roomSize.x / 4),\n                0.1f, // Slightly above ground\n                Random.Range(-roomSize.z / 4, roomSize.z / 4)\n            ) + (Vector3)transform.position;\n\n            // Add visual indicator\n            GameObject indicator = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            indicator.transform.SetParent(waypoint.transform);\n            indicator.transform.localPosition = Vector3.zero;\n            indicator.transform.localScale = Vector3.one * 0.2f;\n\n            Renderer indicatorRenderer = indicator.GetComponent<Renderer>();\n            if (indicatorRenderer != null)\n            {\n                indicatorRenderer.material.color = Color.yellow;\n            }\n\n            // Make non-physical\n            DestroyImmediate(indicator.GetComponent<Collider>());\n\n            waypoint.layer = 12; // Interaction layer\n            spawnedObjects.Add(waypoint);\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-outdoor-environment",children:"2. Outdoor Environment"}),"\n",(0,o.jsx)(e.p,{children:"For outdoor humanoid testing with more complex terrain:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// OutdoorEnvironment.cs - Generate outdoor environment\n\nusing UnityEngine;\nusing System.Collections.Generic;\n\npublic class OutdoorEnvironment : MonoBehaviour\n{\n    [Header("Terrain Settings")]\n    public int terrainWidth = 100;\n    public int terrainLength = 100;\n    public float terrainHeight = 20f;\n\n    [Header("Ground Material")]\n    public PhysicMaterial groundMaterial;\n    public Texture2D groundTexture;\n\n    [Header("Obstacle Configuration")]\n    public int numTrees = 20;\n    public int numRocks = 15;\n    public int numSlopes = 5;\n\n    [Header("Path Settings")]\n    public bool createPath = true;\n    public float pathWidth = 2.0f;\n    public float pathDepth = 0.1f;\n\n    [ContextMenu("Generate Outdoor Environment")]\n    public void GenerateEnvironment()\n    {\n        CreateTerrain();\n        CreateVegetation();\n        CreateNaturalObstacles();\n        CreateSlopes();\n        if (createPath)\n            CreatePath();\n    }\n\n    void CreateTerrain()\n    {\n        // Create a simple flat terrain\n        GameObject terrain = GameObject.CreatePrimitive(PrimitiveType.Plane);\n        terrain.name = "Terrain";\n        terrain.transform.position = transform.position;\n        terrain.transform.localScale = new Vector3(terrainWidth / 10f, 1, terrainLength / 10f);\n        terrain.layer = 9; // Environment layer\n\n        // Apply ground material\n        Renderer terrainRenderer = terrain.GetComponent<Renderer>();\n        if (terrainRenderer != null && groundTexture != null)\n        {\n            terrainRenderer.material.mainTexture = groundTexture;\n            terrainRenderer.material.color = Color.green;\n        }\n\n        // Apply physics material\n        terrain.GetComponent<Collider>().material = groundMaterial;\n\n        // Make static for optimization\n        terrain.isStatic = true;\n    }\n\n    void CreateVegetation()\n    {\n        for (int i = 0; i < numTrees; i++)\n        {\n            Vector3 treePos = new Vector3(\n                Random.Range(-terrainWidth / 2 + 5, terrainWidth / 2 - 5),\n                0,\n                Random.Range(-terrainLength / 2 + 5, terrainLength / 2 - 5)\n            ) + (Vector3)transform.position;\n\n            CreateTree(treePos);\n        }\n    }\n\n    void CreateTree(Vector3 position)\n    {\n        GameObject tree = new GameObject("Tree");\n        tree.transform.position = position;\n        tree.layer = 10; // Obstacle layer\n\n        // Trunk\n        GameObject trunk = GameObject.CreatePrimitive(PrimitiveType.Cylinder);\n        trunk.name = "Trunk";\n        trunk.transform.SetParent(tree.transform);\n        trunk.transform.localPosition = Vector3.zero;\n        trunk.transform.localScale = new Vector3(0.3f, 2f, 0.3f);\n        trunk.transform.Translate(0, 1f, 0); // Center the cylinder properly\n\n        // Leaves (simplified)\n        GameObject leaves = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        leaves.name = "Leaves";\n        leaves.transform.SetParent(tree.transform);\n        leaves.transform.localPosition = new Vector3(0, 2.5f, 0);\n        leaves.transform.localScale = Vector3.one * 1.5f;\n\n        // Remove colliders from decorative parts\n        DestroyImmediate(leaves.GetComponent<Collider>());\n        // Keep trunk collider for navigation challenges\n        trunk.GetComponent<Collider>().material = groundMaterial;\n\n        tree.isStatic = true;\n    }\n\n    void CreateNaturalObstacles()\n    {\n        for (int i = 0; i < numRocks; i++)\n        {\n            Vector3 rockPos = new Vector3(\n                Random.Range(-terrainWidth / 3, terrainWidth / 3),\n                0.2f, // Slightly above ground\n                Random.Range(-terrainLength / 3, terrainLength / 3)\n            ) + (Vector3)transform.position;\n\n            CreateRock(rockPos, Random.Range(0.5f, 2f));\n        }\n    }\n\n    void CreateRock(Vector3 position, float size)\n    {\n        GameObject rock = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        rock.name = "Rock";\n        rock.transform.position = position;\n        rock.transform.localScale = Vector3.one * size;\n        rock.layer = 10; // Obstacle layer\n\n        // Apply rock-like appearance\n        Renderer rockRenderer = rock.GetComponent<Renderer>();\n        if (rockRenderer != null)\n        {\n            rockRenderer.material.color = new Color(0.4f, 0.4f, 0.4f);\n        }\n\n        // Apply physics properties\n        rock.GetComponent<Collider>().material = groundMaterial;\n\n        // Make static for optimization\n        rock.isStatic = true;\n    }\n\n    void CreateSlopes()\n    {\n        for (int i = 0; i < numSlopes; i++)\n        {\n            Vector3 slopePos = new Vector3(\n                Random.Range(-terrainWidth / 4, terrainWidth / 4),\n                0,\n                Random.Range(-terrainLength / 4, terrainLength / 4)\n            ) + (Vector3)transform.position;\n\n            CreateSlope(slopePos, Random.Range(5f, 15f)); // Angle in degrees\n        }\n    }\n\n    void CreateSlope(Vector3 position, float angle)\n    {\n        GameObject slope = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        slope.name = "Slope";\n        slope.transform.position = position;\n        slope.transform.localScale = new Vector3(5f, 0.1f, 3f);\n        slope.transform.rotation = Quaternion.Euler(angle, Random.Range(0, 360), 0);\n        slope.layer = 9; // Environment layer\n\n        // Apply physics material\n        slope.GetComponent<Collider>().material = groundMaterial;\n\n        // Make static for optimization\n        slope.isStatic = true;\n    }\n\n    void CreatePath()\n    {\n        // Create a winding path through the environment\n        int pathSegments = 8;\n        Vector3 startPos = new Vector3(-terrainWidth / 3, 0.01f, -terrainLength / 3) + (Vector3)transform.position;\n\n        for (int i = 0; i < pathSegments; i++)\n        {\n            GameObject pathSegment = GameObject.CreatePrimitive(PrimitiveType.Cube);\n            pathSegment.name = $"Path_Segment_{i}";\n            pathSegment.transform.position = startPos + new Vector3(\n                i * 5f,\n                0.01f, // Slightly above ground\n                Random.Range(-2f, 2f) // Slight variation\n            );\n            pathSegment.transform.localScale = new Vector3(pathWidth, pathDepth, 4f);\n            pathSegment.layer = 9; // Environment layer\n\n            // Apply path material (different from ground)\n            Renderer pathRenderer = pathSegment.GetComponent<Renderer>();\n            if (pathRenderer != null)\n            {\n                pathRenderer.material.color = Color.gray;\n            }\n\n            // Apply physics properties\n            pathSegment.GetComponent<Collider>().material = groundMaterial;\n\n            // Make static for optimization\n            pathSegment.isStatic = true;\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"physics-material-configuration",children:"Physics Material Configuration"}),"\n",(0,o.jsx)(e.h3,{id:"1-creating-physics-materials",children:"1. Creating Physics Materials"}),"\n",(0,o.jsx)(e.p,{children:"Physics materials are crucial for realistic humanoid interaction:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// PhysicsMaterialManager.cs - Create and manage physics materials\n\nusing UnityEngine;\n\n[CreateAssetMenu(fileName = "PhysicsMaterialConfig", menuName = "Robotics/Physics Material Config")]\npublic class PhysicsMaterialConfig : ScriptableObject\n{\n    [Header("Ground Materials")]\n    public PhysicMaterial concrete;\n    public PhysicMaterial grass;\n    public PhysicMaterial wood;\n    public PhysicMaterial carpet;\n\n    [Header("Friction Settings")]\n    [Tooltip("Higher values = more grip, better for walking")]\n    public float highFriction = 0.8f;\n    [Tooltip("Lower values = less grip, more challenging for humanoid")]\n    public float lowFriction = 0.1f;\n\n    [Header("Bounciness Settings")]\n    public float lowBounce = 0.1f;\n    public float highBounce = 0.5f;\n\n    [Header("Custom Materials")]\n    public PhysicMaterial[] customMaterials;\n\n    [ContextMenu("Generate Physics Materials")]\n    public void GenerateMaterials()\n    {\n        // Create standard materials\n        concrete = CreatePhysicsMaterial("Concrete", highFriction, lowBounce);\n        grass = CreatePhysicsMaterial("Grass", highFriction * 0.7f, lowBounce * 0.5f);\n        wood = CreatePhysicsMaterial("Wood", highFriction * 0.9f, lowBounce * 0.8f);\n        carpet = CreatePhysicsMaterial("Carpet", highFriction * 1.2f, lowBounce * 0.3f);\n\n        Debug.Log("Physics materials generated successfully");\n    }\n\n    PhysicMaterial CreatePhysicsMaterial(string name, float friction, float bounce)\n    {\n        PhysicMaterial material = new PhysicMaterial(name);\n        material.staticFriction = friction;\n        material.dynamicFriction = friction * 0.9f; // Dynamic friction is usually slightly lower\n        material.bounciness = bounce;\n        material.frictionCombine = PhysicMaterialCombine.Maximum;\n        material.bounceCombine = PhysicMaterialCombine.Average;\n\n        return material;\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2-terrain-and-surface-variations",children:"2. Terrain and Surface Variations"}),"\n",(0,o.jsx)(e.p,{children:"Create surfaces with different properties for humanoid training:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// SurfaceVarietyManager.cs - Create varied surfaces for training\n\nusing UnityEngine;\nusing System.Collections.Generic;\n\npublic class SurfaceVarietyManager : MonoBehaviour\n{\n    [Header("Surface Configuration")]\n    public PhysicsMaterialConfig materialConfig;\n\n    [Header("Surface Zones")]\n    public int zonesPerEnvironment = 6;\n    public float zoneSize = 3f;\n\n    [Header("Surface Types")]\n    public string[] surfaceNames = { "Concrete", "Grass", "Wood", "Carpet", "Ice", "Sand" };\n    public PhysicMaterial[] surfaceMaterials;\n\n    void Start()\n    {\n        if (materialConfig != null)\n        {\n            surfaceMaterials = new PhysicMaterial[] {\n                materialConfig.concrete,\n                materialConfig.grass,\n                materialConfig.wood,\n                materialConfig.carpet,\n                CreateIceMaterial(),\n                CreateSandMaterial()\n            };\n        }\n    }\n\n    [ContextMenu("Create Surface Zones")]\n    public void CreateSurfaceZones()\n    {\n        for (int i = 0; i < zonesPerEnvironment; i++)\n        {\n            CreateSurfaceZone(i);\n        }\n    }\n\n    void CreateSurfaceZone(int index)\n    {\n        Vector3 position = transform.position + new Vector3(\n            (index % 3) * (zoneSize + 1),\n            0,\n            (index / 3) * (zoneSize + 1)\n        );\n\n        GameObject zone = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        zone.name = $"{surfaceNames[index % surfaceNames.Length]}_Zone";\n        zone.transform.position = position;\n        zone.transform.localScale = new Vector3(zoneSize, 0.1f, zoneSize);\n        zone.layer = 9; // Environment layer\n\n        // Apply appropriate material\n        if (index < surfaceMaterials.Length)\n        {\n            zone.GetComponent<Collider>().material = surfaceMaterials[index];\n\n            // Apply visual color coding\n            Renderer rend = zone.GetComponent<Renderer>();\n            if (rend != null)\n            {\n                switch (index % surfaceNames.Length)\n                {\n                    case 0: rend.material.color = Color.gray; break;      // Concrete\n                    case 1: rend.material.color = Color.green; break;     // Grass\n                    case 2: rend.material.color = Color.yellow; break;    // Wood\n                    case 3: rend.material.color = Color.red; break;       // Carpet\n                    case 4: rend.material.color = Color.cyan; break;      // Ice\n                    case 5: rend.material.color = Color.white; break;     // Sand\n                }\n            }\n        }\n\n        // Make static for optimization\n        zone.isStatic = true;\n    }\n\n    PhysicMaterial CreateIceMaterial()\n    {\n        PhysicMaterial ice = new PhysicMaterial("Ice");\n        ice.staticFriction = 0.1f;\n        ice.dynamicFriction = 0.05f;\n        ice.bounciness = 0.0f;\n        return ice;\n    }\n\n    PhysicMaterial CreateSandMaterial()\n    {\n        PhysicMaterial sand = new PhysicMaterial("Sand");\n        sand.staticFriction = 0.8f;\n        sand.dynamicFriction = 0.7f;\n        sand.bounciness = 0.1f;\n        return sand;\n    }\n\n    // Method to test robot on different surfaces\n    public PhysicMaterial GetRandomSurfaceMaterial()\n    {\n        if (surfaceMaterials.Length > 0)\n        {\n            int randomIndex = Random.Range(0, surfaceMaterials.Length);\n            return surfaceMaterials[randomIndex];\n        }\n        return null;\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"navigation-and-waypoint-systems",children:"Navigation and Waypoint Systems"}),"\n",(0,o.jsx)(e.h3,{id:"1-waypoint-manager-for-training",children:"1. Waypoint Manager for Training"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// WaypointNavigationSystem.cs - Create navigation challenges\n\nusing UnityEngine;\nusing System.Collections.Generic;\n\npublic class WaypointNavigationSystem : MonoBehaviour\n{\n    [Header("Waypoint Configuration")]\n    public List<Transform> waypoints = new List<Transform>();\n    public Color waypointColor = Color.yellow;\n    public float waypointSize = 0.3f;\n\n    [Header("Navigation Challenges")]\n    public bool createNarrowPath = true;\n    public bool createObstacleCourse = true;\n    public bool createElevationChanges = true;\n\n    [Header("Challenge Parameters")]\n    public int narrowPathWidth = 1; // Number of waypoints wide\n    public float obstacleDensity = 0.3f; // 0-1\n\n    [ContextMenu("Generate Navigation Course")]\n    public void GenerateNavigationCourse()\n    {\n        ClearWaypoints();\n        CreateWaypointPath();\n        if (createObstacleCourse)\n            CreateObstacleCourse();\n        if (createElevationChanges)\n            CreateElevationChanges();\n    }\n\n    void ClearWaypoints()\n    {\n        foreach (Transform waypoint in waypoints)\n        {\n            if (waypoint != null)\n                DestroyImmediate(waypoint.gameObject);\n        }\n        waypoints.Clear();\n    }\n\n    void CreateWaypointPath()\n    {\n        // Create a serpentine path\n        int numWaypoints = 20;\n        float spacing = 2f;\n\n        for (int i = 0; i < numWaypoints; i++)\n        {\n            Vector3 pos = transform.position + new Vector3(\n                Mathf.Sin(i * 0.5f) * 5f, // Create curves\n                0.1f, // Above ground\n                i * spacing\n            );\n\n            GameObject waypointObj = new GameObject($"Waypoint_{i}");\n            waypointObj.transform.position = pos;\n\n            // Visual indicator\n            GameObject indicator = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            indicator.transform.SetParent(waypointObj.transform);\n            indicator.transform.localPosition = Vector3.zero;\n            indicator.transform.localScale = Vector3.one * waypointSize;\n            indicator.GetComponent<Renderer>().material.color = waypointColor;\n\n            // Make non-physical\n            DestroyImmediate(indicator.GetComponent<Collider>());\n\n            waypoints.Add(waypointObj.transform);\n        }\n    }\n\n    void CreateObstacleCourse()\n    {\n        // Add obstacles around some waypoints to create challenges\n        for (int i = 3; i < waypoints.Count - 3; i += 4) // Every 4th waypoint\n        {\n            if (Random.value < obstacleDensity)\n            {\n                CreateObstacleCluster(waypoints[i].position);\n            }\n        }\n    }\n\n    void CreateObstacleCluster(Vector3 centerPos)\n    {\n        int numObstacles = Random.Range(2, 5);\n\n        for (int i = 0; i < numObstacles; i++)\n        {\n            Vector3 offset = new Vector3(\n                Random.Range(-2f, 2f),\n                Random.Range(0.5f, 2f),\n                Random.Range(-2f, 2f)\n            );\n\n            GameObject obstacle = GameObject.CreatePrimitive(PrimitiveType.Cylinder);\n            obstacle.name = "Navigation_Obstacle";\n            obstacle.transform.position = centerPos + offset;\n            obstacle.transform.localScale = new Vector3(0.5f, 1f, 0.5f);\n            obstacle.layer = 10; // Obstacle layer\n\n            // Apply physics properties\n            obstacle.GetComponent<Collider>().material = new PhysicMaterial\n            {\n                staticFriction = 0.7f,\n                dynamicFriction = 0.6f\n            };\n\n            // Make static\n            obstacle.isStatic = true;\n        }\n    }\n\n    void CreateElevationChanges()\n    {\n        // Create some elevation changes by moving certain waypoints up/down\n        for (int i = 5; i < waypoints.Count; i += 6) // Every 6th waypoint\n        {\n            Vector3 newPos = waypoints[i].position;\n            newPos.y += Random.Range(0.5f, 2f); // Raise this waypoint\n            waypoints[i].position = newPos;\n\n            // Create a ramp or step up to this waypoint\n            CreateRamp(waypoints[i - 1].position, newPos);\n        }\n    }\n\n    void CreateRamp(Vector3 startPos, Vector3 endPos)\n    {\n        Vector3 rampSize = new Vector3(2f, 0.1f, Vector3.Distance(startPos, endPos));\n        Vector3 rampPos = startPos + (endPos - startPos) / 2f;\n        rampPos.y = (startPos.y + endPos.y) / 2f;\n\n        GameObject ramp = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        ramp.name = "Ramp";\n        ramp.transform.position = rampPos;\n\n        // Rotate to match the slope\n        Vector3 direction = endPos - startPos;\n        ramp.transform.rotation = Quaternion.LookRotation(direction, Vector3.up);\n\n        ramp.transform.localScale = rampSize;\n        ramp.layer = 9; // Environment layer\n\n        // Apply physics properties\n        ramp.GetComponent<Collider>().material = new PhysicMaterial\n        {\n            staticFriction = 0.8f\n        };\n\n        // Make static\n        ramp.isStatic = true;\n    }\n\n    // Get next waypoint in sequence\n    public Transform GetNextWaypoint(int currentIndex)\n    {\n        if (waypoints.Count > 0)\n        {\n            return waypoints[(currentIndex + 1) % waypoints.Count];\n        }\n        return null;\n    }\n\n    // Get closest waypoint to a position\n    public Transform GetClosestWaypoint(Vector3 position)\n    {\n        Transform closest = null;\n        float closestDistance = float.MaxValue;\n\n        foreach (Transform waypoint in waypoints)\n        {\n            float distance = Vector3.Distance(position, waypoint.position);\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closest = waypoint;\n            }\n        }\n\n        return closest;\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"environment-testing-and-validation",children:"Environment Testing and Validation"}),"\n",(0,o.jsx)(e.h3,{id:"1-environment-validation-script",children:"1. Environment Validation Script"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// EnvironmentValidator.cs - Validate environment for humanoid use\n\nusing UnityEngine;\n\npublic class EnvironmentValidator : MonoBehaviour\n{\n    [Header("Validation Settings")]\n    public float minimumWalkwayWidth = 0.8f; // Minimum width for humanoid passage\n    public float maximumStepHeight = 0.2f;   // Maximum step height humanoid can handle\n    public float safeCeilingHeight = 2.5f;   // Minimum ceiling height\n\n    [Header("Validation Results")]\n    [TextArea]\n    public string validationReport = "";\n\n    [ContextMenu("Validate Environment")]\n    public void ValidateEnvironment()\n    {\n        validationReport = "Environment Validation Report:\\n\\n";\n\n        // Check walkway widths\n        bool walkwaysValid = CheckWalkwayWidths();\n        validationReport += $"Walkway Widths: {(walkwaysValid ? "PASS" : "FAIL")}\\n";\n\n        // Check step heights\n        bool stepsValid = CheckStepHeights();\n        validationReport += $"Step Heights: {(stepsValid ? "PASS" : "FAIL")}\\n";\n\n        // Check ceiling heights\n        bool ceilingValid = CheckCeilingHeights();\n        validationReport += $"Ceiling Heights: {(ceilingValid ? "PASS" : "FAIL")}\\n";\n\n        // Check for physics issues\n        bool physicsValid = CheckPhysicsSetup();\n        validationReport += $"Physics Setup: {(physicsValid ? "PASS" : "FAIL")}\\n";\n\n        Debug.Log(validationReport);\n    }\n\n    bool CheckWalkwayWidths()\n    {\n        // For simplicity, this checks a few key areas\n        // In practice, you\'d want more comprehensive pathfinding validation\n        Collider[] obstacles = Physics.OverlapBox(\n            transform.position,\n            new Vector3(20f, 2f, 20f), // Check area around environment\n            Quaternion.identity,\n            1 << 10 // Only check obstacle layer\n        );\n\n        // Check if any obstacles are too narrow for humanoid passage\n        foreach (Collider obstacle in obstacles)\n        {\n            Vector3 size = obstacle.bounds.size;\n            if (size.x < minimumWalkwayWidth && size.z < minimumWalkwayWidth)\n            {\n                validationReport += $"  - Narrow obstacle detected: {obstacle.name}\\n";\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    bool CheckStepHeights()\n    {\n        // Check for steps that are too high\n        RaycastHit[] hits = Physics.RaycastAll(\n            transform.position + Vector3.up * 10f, // Ray from above\n            Vector3.down,\n            20f, // Ray distance\n            1 << 9 // Environment layer\n        );\n\n        // Group hits by x,z position to find height differences\n        for (int i = 0; i < hits.Length - 1; i++)\n        {\n            for (int j = i + 1; j < hits.Length; j++)\n            {\n                // If points are close horizontally but have large height difference\n                float horizontalDistance = Vector2.Distance(\n                    new Vector2(hits[i].point.x, hits[i].point.z),\n                    new Vector2(hits[j].point.x, hits[j].point.z)\n                );\n\n                if (horizontalDistance < 1f) // Close horizontally\n                {\n                    float heightDiff = Mathf.Abs(hits[i].point.y - hits[j].point.y);\n                    if (heightDiff > maximumStepHeight)\n                    {\n                        validationReport += $"  - Large step detected: {heightDiff:F2}m\\n";\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    bool CheckCeilingHeights()\n    {\n        // Check for low ceilings that could hit humanoid head\n        RaycastHit hit;\n        if (Physics.Raycast(\n            transform.position,\n            Vector3.up,\n            out hit,\n            4f, // Check up to 4m\n            1 << 9 // Environment layer\n        ))\n        {\n            float ceilingHeight = hit.distance;\n            if (ceilingHeight < safeCeilingHeight)\n            {\n                validationReport += $"  - Low ceiling: {ceilingHeight:F2}m at {hit.point}\\n";\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    bool CheckPhysicsSetup()\n    {\n        // Check if required physics materials are assigned\n        if (Physics.GetIgnoreLayerCollision(8, 9)) // Robot vs Environment\n        {\n            validationReport += "  - Robot may not collide with environment\\n";\n            return false;\n        }\n\n        // Check if static objects are properly marked\n        int staticObjects = 0;\n        Collider[] allColliders = FindObjectsOfType<Collider>();\n        foreach (Collider col in allColliders)\n        {\n            if (col.transform.root == transform && col.GetComponent<Rigidbody>() == null)\n            {\n                staticObjects++;\n            }\n        }\n\n        validationReport += $"  - Found {staticObjects} static objects\\n";\n        return staticObjects > 0; // Should have some static objects\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"Now that you have created comprehensive environments for humanoid robots in Unity, let's explore how to establish proper communication between Unity and ROS 2 systems. In the next section, we'll cover ROS communication implementation specifically for Unity environments."})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(m,{...n})}):m(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);