"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2991],{6225:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"module-2-digital-twin/gazebo-simulation/physics-modeling","title":"Physics Modeling for Humanoid Robots","description":"Overview","source":"@site/docs/module-2-digital-twin/gazebo-simulation/physics-modeling.md","sourceDirName":"module-2-digital-twin/gazebo-simulation","slug":"/module-2-digital-twin/gazebo-simulation/physics-modeling","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/gazebo-simulation/physics-modeling","draft":false,"unlisted":false,"editUrl":"https://github.com/Jiyakhan321/hackathon_textbook_ai_robotics/tree/main/docs/module-2-digital-twin/gazebo-simulation/physics-modeling.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Environment Design in Gazebo","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/gazebo-simulation/environment-design"},"next":{"title":"Gazebo-ROS Integration","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/gazebo-simulation/gazebo-ros-integration"}}');var t=i(4848),o=i(8453);const r={sidebar_position:2},a="Physics Modeling for Humanoid Robots",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Understanding Gazebo Physics Engines",id:"understanding-gazebo-physics-engines",level:2},{value:"ODE Physics Configuration",id:"ode-physics-configuration",level:3},{value:"Key Physics Parameters for Humanoid Robots",id:"key-physics-parameters-for-humanoid-robots",level:2},{value:"1. Time Step Considerations",id:"1-time-step-considerations",level:3},{value:"2. Solver Configuration",id:"2-solver-configuration",level:3},{value:"3. Constraint Parameters",id:"3-constraint-parameters",level:3},{value:"Link Physics Properties",id:"link-physics-properties",level:2},{value:"1. Inertial Properties",id:"1-inertial-properties",level:3},{value:"2. Surface Properties for Contacts",id:"2-surface-properties-for-contacts",level:3},{value:"Joint Physics Configuration",id:"joint-physics-configuration",level:2},{value:"1. Revolute Joint with Dynamics",id:"1-revolute-joint-with-dynamics",level:3},{value:"2. Advanced Joint Dynamics",id:"2-advanced-joint-dynamics",level:3},{value:"Physics Optimization for Humanoid Robots",id:"physics-optimization-for-humanoid-robots",level:2},{value:"1. Balancing Accuracy and Performance",id:"1-balancing-accuracy-and-performance",level:3},{value:"2. Per-Link Physics Optimization",id:"2-per-link-physics-optimization",level:3},{value:"Advanced Physics Concepts",id:"advanced-physics-concepts",level:2},{value:"1. Multi-Body Dynamics",id:"1-multi-body-dynamics",level:3},{value:"2. Contact Stabilization",id:"2-contact-stabilization",level:3},{value:"Debugging Physics Issues",id:"debugging-physics-issues",level:2},{value:"1. Common Physics Problems",id:"1-common-physics-problems",level:3},{value:"2. Physics Debug Visualization",id:"2-physics-debug-visualization",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"1. Optimizing for Real-time Simulation",id:"1-optimizing-for-real-time-simulation",level:3},{value:"2. Optimizing for Accuracy",id:"2-optimizing-for-accuracy",level:3},{value:"Testing Physics Configurations",id:"testing-physics-configurations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"physics-modeling-for-humanoid-robots",children:"Physics Modeling for Humanoid Robots"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Physics modeling is crucial for creating realistic humanoid robot simulations in Gazebo. The physics engine determines how your robot interacts with the environment, how forces are applied, and how movements are constrained. This section covers the essential physics concepts and configurations needed for accurate humanoid simulation."}),"\n",(0,t.jsx)(n.h2,{id:"understanding-gazebo-physics-engines",children:"Understanding Gazebo Physics Engines"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo supports several physics engines, but for humanoid robots, Open Dynamics Engine (ODE) is most commonly used due to its stability and performance characteristics."}),"\n",(0,t.jsx)(n.h3,{id:"ode-physics-configuration",children:"ODE Physics Configuration"}),"\n",(0,t.jsx)(n.p,{children:"The physics configuration significantly affects humanoid robot simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<physics type="ode">\n  \x3c!-- Time step settings --\x3e\n  <max_step_size>0.001</max_step_size>      \x3c!-- 1ms time step (1000 Hz) --\x3e\n  <real_time_factor>1.0</real_time_factor>  \x3c!-- Real-time simulation --\x3e\n  <real_time_update_rate>1000.0</real_time_update_rate>  \x3c!-- Update rate --\x3e\n\n  \x3c!-- ODE-specific parameters --\x3e\n  <ode>\n    \x3c!-- Solver settings --\x3e\n    <solver>\n      <type>quick</type>     \x3c!-- QuickStep solver for better performance --\x3e\n      <iters>100</iters>     \x3c!-- Solver iterations (higher = more accurate but slower) --\x3e\n      <sor>1.3</sor>         \x3c!-- Successive Over-Relaxation parameter --\x3e\n    </solver>\n\n    \x3c!-- Constraint settings for stable contacts --\x3e\n    <constraints>\n      <cfm>0.000001</cfm>                    \x3c!-- Constraint Force Mixing --\x3e\n      <erp>0.2</erp>                        \x3c!-- Error Reduction Parameter --\x3e\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>  \x3c!-- Max correction velocity --\x3e\n      <contact_surface_layer>0.001</contact_surface_layer>          \x3c!-- Contact surface layer --\x3e\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"key-physics-parameters-for-humanoid-robots",children:"Key Physics Parameters for Humanoid Robots"}),"\n",(0,t.jsx)(n.h3,{id:"1-time-step-considerations",children:"1. Time Step Considerations"}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robots, the time step is critical for stable control:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- For precise control, use smaller time steps --\x3e\n<max_step_size>0.001</max_step_size>  \x3c!-- 1ms - good for control systems --\x3e\n\x3c!-- OR --\x3e\n<max_step_size>0.0005</max_step_size>  \x3c!-- 0.5ms - more precise but slower --\x3e\n\n\x3c!-- For less critical simulations --\x3e\n<max_step_size>0.01</max_step_size>   \x3c!-- 10ms - faster but less precise --\x3e\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-solver-configuration",children:"2. Solver Configuration"}),"\n",(0,t.jsx)(n.p,{children:"The solver configuration affects how contacts and constraints are resolved:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<solver>\n  \x3c!-- For humanoid robots with many joints --\x3e\n  <type>quick</type>\n  <iters>100</iters>        \x3c!-- Start with 100, increase if unstable --\x3e\n  <sor>1.3</sor>            \x3c!-- Usually between 1.0-1.5 --\x3e\n\n  \x3c!-- Alternative for more stability (slower) --\x3e\n  \x3c!--\n  <iters>200</iters>\n  <sor>1.0</sor>\n  --\x3e\n</solver>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-constraint-parameters",children:"3. Constraint Parameters"}),"\n",(0,t.jsx)(n.p,{children:"These parameters are crucial for stable foot contacts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<constraints>\n  \x3c!-- CFM (Constraint Force Mixing) - lower values = stiffer constraints --\x3e\n  <cfm>0.000001</cfm>       \x3c!-- Very low for stable contacts --\x3e\n\n  \x3c!-- ERP (Error Reduction Parameter) - how fast errors are corrected --\x3e\n  <erp>0.2</erp>            \x3c!-- 0.1-0.8 typically, 0.2 is good start --\x3e\n\n  \x3c!-- Maximum velocity for contact correction --\x3e\n  <contact_max_correcting_vel>100</contact_max_correcting_vel>\n\n  \x3c!-- Surface layer thickness to prevent deep penetration --\x3e\n  <contact_surface_layer>0.001</contact_surface_layer>  \x3c!-- 1mm --\x3e\n</constraints>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"link-physics-properties",children:"Link Physics Properties"}),"\n",(0,t.jsx)(n.p,{children:"Each link in your humanoid robot needs proper physics properties:"}),"\n",(0,t.jsx)(n.h3,{id:"1-inertial-properties",children:"1. Inertial Properties"}),"\n",(0,t.jsx)(n.p,{children:"Accurate inertial properties are essential for realistic simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<link name="left_thigh_link">\n  <inertial>\n    \x3c!-- Mass in kg --\x3e\n    <mass>5.0</mass>\n\n    \x3c!-- Origin offset (usually center of mass) --\x3e\n    <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n\n    \x3c!-- Inertia matrix (calculated based on geometry) --\x3e\n    <inertia\n      ixx="0.1" ixy="0.0" ixz="0.0"\n      iyy="0.1" iyz="0.0"\n      izz="0.02"/>\n  </inertial>\n\n  \x3c!-- Visual properties --\x3e\n  <visual name="visual">\n    <geometry>\n      <capsule radius="0.08" length="0.35"/>\n    </geometry>\n  </visual>\n\n  \x3c!-- Collision properties --\x3e\n  <collision name="collision">\n    <geometry>\n      <capsule radius="0.08" length="0.35"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-surface-properties-for-contacts",children:"2. Surface Properties for Contacts"}),"\n",(0,t.jsx)(n.p,{children:"Surface properties affect how your robot interacts with the environment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<link name="left_foot_link">\n  <inertial>\n    <mass>2.0</mass>\n    <origin xyz="0.08 0 -0.02" rpy="0 0 0"/>\n    <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.02"/>\n  </inertial>\n\n  <collision name="collision">\n    <geometry>\n      <box size="0.25 0.12 0.08"/>\n    </geometry>\n\n    \x3c!-- Surface properties for foot-ground contact --\x3e\n    <surface>\n      <friction>\n        <ode>\n          <mu>0.8</mu>      \x3c!-- Coefficient of friction --\x3e\n          <mu2>0.8</mu2>    \x3c!-- Secondary friction coefficient --\x3e\n          <fdir1>0 0 0</fdir1>  \x3c!-- Friction direction --\x3e\n        </ode>\n      </friction>\n\n      <bounce>\n        <restitution_coefficient>0.1</restitution_coefficient>  \x3c!-- Bounciness --\x3e\n        <threshold>100000</threshold>  \x3c!-- Velocity threshold for bounce --\x3e\n      </bounce>\n\n      <contact>\n        <ode>\n          <soft_cfm>0.000001</soft_cfm>      \x3c!-- Soft constraint force mixing --\x3e\n          <soft_erp>0.2</soft_erp>           \x3c!-- Soft error reduction parameter --\x3e\n          <kp>1000000000000.0</kp>          \x3c!-- Contact stiffness --\x3e\n          <kd>1.0</kd>                      \x3c!-- Contact damping --\x3e\n          <max_vel>100.0</max_vel>          \x3c!-- Maximum contact correction velocity --\x3e\n          <min_depth>0.001</min_depth>      \x3c!-- Minimum contact depth --\x3e\n        </ode>\n      </contact>\n    </surface>\n  </collision>\n\n  <visual name="visual">\n    <geometry>\n      <box size="0.25 0.12 0.08"/>\n    </geometry>\n  </visual>\n</link>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"joint-physics-configuration",children:"Joint Physics Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Joints need proper dynamics for realistic movement:"}),"\n",(0,t.jsx)(n.h3,{id:"1-revolute-joint-with-dynamics",children:"1. Revolute Joint with Dynamics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<joint name="left_knee_joint" type="revolute">\n  <parent link="left_thigh_link"/>\n  <child link="left_shin_link"/>\n  <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>  \x3c!-- Knee rotation axis --\x3e\n\n  \x3c!-- Joint limits --\x3e\n  <limit lower="0.0" upper="2.35" effort="250" velocity="1.5"/>\n\n  \x3c!-- Joint dynamics --\x3e\n  <dynamics damping="1.0" friction="0.2"/>\n</joint>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-advanced-joint-dynamics",children:"2. Advanced Joint Dynamics"}),"\n",(0,t.jsx)(n.p,{children:"For more realistic joint behavior:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<joint name="left_shoulder_joint" type="revolute">\n  <parent link="torso_upper"/>\n  <child link="left_upper_arm_link"/>\n  <origin xyz="0.16 0.08 0.25" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-2.0" upper="2.0" effort="100" velocity="1.5"/>\n\n  \x3c!-- Detailed dynamics for realistic movement --\x3e\n  <dynamics\n    damping="0.5"           \x3c!-- Viscous damping coefficient --\x3e\n    friction="0.1"          \x3c!-- Static friction coefficient --\x3e\n    spring_reference="0.0"  \x3c!-- Spring reference angle --\x3e\n    spring_stiffness="0.0"  \x3c!-- Spring stiffness --\x3e\n  />\n</joint>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"physics-optimization-for-humanoid-robots",children:"Physics Optimization for Humanoid Robots"}),"\n",(0,t.jsx)(n.h3,{id:"1-balancing-accuracy-and-performance",children:"1. Balancing Accuracy and Performance"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Optimized physics for humanoid simulation --\x3e\n<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000.0</real_time_update_rate>\n\n  <ode>\n    <solver>\n      \x3c!-- Good balance for humanoid: 50-100 iterations --\x3e\n      <type>quick</type>\n      <iters>80</iters>\n      <sor>1.2</sor>\n    </solver>\n\n    <constraints>\n      \x3c!-- Stable values for humanoid contacts --\x3e\n      <cfm>0.00001</cfm>    \x3c!-- Slightly higher for performance --\x3e\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>10</contact_max_correcting_vel>  \x3c!-- Lower for stability --\x3e\n      <contact_surface_layer>0.002</contact_surface_layer>         \x3c!-- Slightly thicker --\x3e\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-per-link-physics-optimization",children:"2. Per-Link Physics Optimization"}),"\n",(0,t.jsx)(n.p,{children:"For complex humanoid robots, you might need different physics settings for different parts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Light, fast-moving parts (hands, feet) --\x3e\n<link name="left_hand_link">\n  <inertial>\n    <mass>0.8</mass>  \x3c!-- Lower mass for faster response --\x3e\n    <origin xyz="0.06 0 0" rpy="0 0 0"/>\n    <inertia ixx="0.002" ixy="0" ixz="0" iyy="0.003" iyz="0" izz="0.003"/>\n  </inertial>\n\n  <collision name="collision">\n    <geometry>\n      <box size="0.12 0.08 0.06"/>\n    </geometry>\n    <surface>\n      <contact>\n        <ode>\n          <soft_cfm>0.00001</soft_cfm>\n          <soft_erp>0.1</soft_erp>  \x3c!-- Lower ERP for precision --\x3e\n        </ode>\n      </contact>\n    </surface>\n  </collision>\n</link>\n\n\x3c!-- Heavy, stable parts (torso, pelvis) --\x3e\n<link name="base_link">\n  <inertial>\n    <mass>12.0</mass>  \x3c!-- Higher mass for stability --\x3e\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <inertia ixx="0.25" ixy="0" ixz="0" iyy="0.25" iyz="0" izz="0.2"/>\n  </inertial>\n\n  <collision name="collision">\n    <geometry>\n      <box size="0.28 0.25 0.1"/>\n    </geometry>\n    <surface>\n      <contact>\n        <ode>\n          <soft_cfm>0.0001</soft_cfm>  \x3c!-- Higher CFM for stability --\x3e\n          <soft_erp>0.3</soft_erp>     \x3c!-- Higher ERP for stability --\x3e\n        </ode>\n      </contact>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-physics-concepts",children:"Advanced Physics Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"1-multi-body-dynamics",children:"1. Multi-Body Dynamics"}),"\n",(0,t.jsx)(n.p,{children:"For complex humanoid robots with many interconnected parts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example of a complex chain --\x3e\n<model name="humanoid_with_physics">\n  \x3c!-- Physics properties for the entire model can be set here --\x3e\n  <static>false</static>  \x3c!-- Model is dynamic --\x3e\n\n  \x3c!-- Links with appropriate physics as shown above --\x3e\n  \x3c!-- ... --\x3e\n\n  \x3c!-- Self-collision can be enabled if needed --\x3e\n  <self_collide>false</self_collide>  \x3c!-- Usually false for humanoid --\x3e\n\n  \x3c!-- Enable/disable gravity for the entire model --\x3e\n  <gravity>true</gravity>\n</model>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-contact-stabilization",children:"2. Contact Stabilization"}),"\n",(0,t.jsx)(n.p,{children:"For stable walking and standing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In your world file --\x3e\n<world name="humanoid_stable_world">\n  <physics type="ode">\n    \x3c!-- Stable physics configuration --\x3e\n    <max_step_size>0.001</max_step_size>\n    <real_time_factor>1.0</real_time_factor>\n\n    <ode>\n      <solver>\n        <type>quick</type>\n        <iters>100</iters>  \x3c!-- Higher for stability --\x3e\n        <sor>1.0</sor>      \x3c!-- Lower SOR for more accurate solution --\x3e\n      </solver>\n\n      <constraints>\n        <cfm>0.000001</cfm>  \x3c!-- Very low for stiff contacts --\x3e\n        <erp>0.1</erp>      \x3c!-- Lower ERP for less aggressive error correction --\x3e\n        <contact_max_correcting_vel>5</contact_max_correcting_vel>  \x3c!-- Lower for stability --\x3e\n        <contact_surface_layer>0.001</contact_surface_layer>\n      </constraints>\n    </ode>\n  </physics>\n\n  \x3c!-- Your robot and environment models --\x3e\n</world>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"debugging-physics-issues",children:"Debugging Physics Issues"}),"\n",(0,t.jsx)(n.h3,{id:"1-common-physics-problems",children:"1. Common Physics Problems"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Problem: Robot falls through ground"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check if ground plane is static"}),"\n",(0,t.jsx)(n.li,{children:"Verify collision geometry exists"}),"\n",(0,t.jsx)(n.li,{children:"Check physics parameters (CFM/ERP)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Problem: Robot jitters or shakes"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Increase solver iterations"}),"\n",(0,t.jsx)(n.li,{children:"Adjust CFM/ERP values"}),"\n",(0,t.jsx)(n.li,{children:"Check joint limits and dynamics"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Problem: Robot moves too slowly or not at all"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check effort limits in joints"}),"\n",(0,t.jsx)(n.li,{children:"Verify controller commands are being sent"}),"\n",(0,t.jsx)(n.li,{children:"Check friction values"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-physics-debug-visualization",children:"2. Physics Debug Visualization"}),"\n",(0,t.jsx)(n.p,{children:"Add this to your world file for physics debugging:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In your world file, add physics visualization --\x3e\n<world name="debug_world">\n  \x3c!-- ... physics settings ... --\x3e\n\n  \x3c!-- Enable contact visualization --\x3e\n  <gui>\n    <camera name="user_camera">\n      <pose>5 -5 2 0 0.5 1.5708</pose>\n    </camera>\n  </gui>\n\n  \x3c!-- Physics engine settings --\x3e\n  <physics type="ode">\n    \x3c!-- Your physics settings --\x3e\n  </physics>\n</world>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"1-optimizing-for-real-time-simulation",children:"1. Optimizing for Real-time Simulation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- For real-time control applications --\x3e\n<physics type="ode">\n  <max_step_size>0.002</max_step_size>  \x3c!-- Larger time step for performance --\x3e\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>500.0</real_time_update_rate>  \x3c!-- Lower update rate --\x3e\n\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>50</iters>  \x3c!-- Lower iterations for speed --\x3e\n      <sor>1.3</sor>\n    </solver>\n\n    <constraints>\n      <cfm>0.0001</cfm>  \x3c!-- Higher CFM for performance --\x3e\n      <erp>0.3</erp>    \x3c!-- Higher ERP for performance --\x3e\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-optimizing-for-accuracy",children:"2. Optimizing for Accuracy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- For high-precision simulation --\x3e\n<physics type="ode">\n  <max_step_size>0.0005</max_step_size>  \x3c!-- Very small time step --\x3e\n  <real_time_factor>0.5</real_time_factor>  \x3c!-- Allow slower than real-time --\x3e\n  <real_time_update_rate>2000.0</real_time_update_rate>\n\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>200</iters>  \x3c!-- High iterations for accuracy --\x3e\n      <sor>1.0</sor>\n    </solver>\n\n    <constraints>\n      <cfm>0.0000001</cfm>  \x3c!-- Very low CFM for stiffness --\x3e\n      <erp>0.1</erp>       \x3c!-- Low ERP for precision --\x3e\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"testing-physics-configurations",children:"Testing Physics Configurations"}),"\n",(0,t.jsx)(n.p,{children:"Create a simple test script to validate your physics setup:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n# physics_test.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import PointStamped\nimport time\n\nclass PhysicsTestNode(Node):\n    def __init__(self):\n        super().__init__('physics_test_node')\n\n        # Subscribe to joint states to monitor robot stability\n        self.joint_sub = self.create_subscription(\n            JointState, 'joint_states', self.joint_callback, 10)\n\n        # Subscribe to IMU data for balance monitoring\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback, 10)\n\n        # Timer for periodic checks\n        self.timer = self.create_timer(1.0, self.periodic_check)\n\n        self.joint_states = None\n        self.imu_data = None\n        self.check_count = 0\n\n        self.get_logger().info('Physics test node initialized')\n\n    def joint_callback(self, msg):\n        self.joint_states = msg\n\n    def imu_callback(self, msg):\n        self.imu_data = msg\n\n    def periodic_check(self):\n        self.check_count += 1\n\n        if self.joint_states:\n            # Check for reasonable joint positions (not flying away)\n            max_pos = max(abs(p) for p in self.joint_states.position)\n            if max_pos > 10.0:  # Unreasonable position\n                self.get_logger().warn(f'Large joint position detected: {max_pos}')\n\n            # Check for reasonable velocities\n            if self.joint_states.velocity:\n                max_vel = max(abs(v) for v in self.joint_states.velocity)\n                if max_vel > 100.0:  # Unreasonable velocity\n                    self.get_logger().warn(f'Large joint velocity detected: {max_vel}')\n\n        if self.imu_data:\n            # Check if robot is upright (simplified)\n            z_orientation = self.imu_data.orientation.z\n            if abs(z_orientation) > 0.7:  # Robot might be falling\n                self.get_logger().info(f'Robot orientation: {z_orientation}')\n\n        if self.check_count % 10 == 0:  # Every 10 seconds\n            self.get_logger().info(f'Physics check #{self.check_count}: OK')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = PhysicsTestNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Physics test node shutting down')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(n.p,{children:"Now that you understand physics modeling for humanoid robots, let's explore how to integrate your simulation with ROS 2 through Gazebo plugins. In the next section, we'll cover the Gazebo-ROS integration that allows your simulated humanoid robot to communicate with the ROS 2 ecosystem."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);